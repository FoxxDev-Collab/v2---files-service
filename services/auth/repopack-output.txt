This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-09-11T20:18:08.709Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
_tests_/auth.test.js
check-permissions.js
database.json
db.js
db.ts
Dockerfile.test
manual-migration.js
migrations/20240311120000_add_profile_picture_url.sql
package.json
run-migration.js
server.js
src/auth.ts
src/Dockerfile
src/routes/auth.ts
src/server.ts
test-db-connection.js
tsconfig.json

================================================================
Repository Files
================================================================

================
File: _tests_/auth.test.js
================
// services/auth/__tests__/auth.test.js
const request = require('supertest');
const app = require('../src/server'); // Assuming your Express app is exported from server.js

describe('Auth Service', () => {
  test('POST /register should create a new user', async () => {
    const res = await request(app)
      .post('/register')
      .send({
        username: 'testuser',
        password: 'testpassword'
      });
    expect(res.statusCode).toBe(201);
    expect(res.body).toHaveProperty('message', 'User created successfully');
  });

  test('POST /login should authenticate a user', async () => {
    const res = await request(app)
      .post('/login')
      .send({
        username: 'testuser',
        password: 'testpassword'
      });
    expect(res.statusCode).toBe(200);
    expect(res.body).toHaveProperty('token');
  });
});

================
File: check-permissions.js
================
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: parseInt(process.env.DB_PORT || '5432'),
});

async function checkPermissions() {
  const client = await pool.connect();
  try {
    // Set search_path
    await client.query('SET search_path TO newcloud_schema, public');

    // Check table ownership
    const ownershipQuery = `
      SELECT tableowner 
      FROM pg_tables 
      WHERE schemaname = 'newcloud_schema' AND tablename = 'users'
    `;
    const ownershipResult = await client.query(ownershipQuery);
    console.log('Table owner:', ownershipResult.rows[0]?.tableowner);

    // Check user permissions
    const permissionsQuery = `
      SELECT grantee, privilege_type 
      FROM information_schema.role_table_grants 
      WHERE table_schema = 'newcloud_schema' 
      AND table_name = 'users' 
      AND grantee = $1
    `;
    const permissionsResult = await client.query(permissionsQuery, [process.env.DB_USER]);
    console.log('User permissions:', permissionsResult.rows);

    // Check if user is a superuser
    const superuserQuery = `
      SELECT rolsuper 
      FROM pg_roles 
      WHERE rolname = $1
    `;
    const superuserResult = await client.query(superuserQuery, [process.env.DB_USER]);
    console.log('Is superuser:', superuserResult.rows[0]?.rolsuper);

  } catch (err) {
    console.error('Error checking permissions:', err);
  } finally {
    client.release();
    await pool.end();
  }
}

checkPermissions();

================
File: database.json
================
{
    "dev": {
      "driver": "pg",
      "user": "newcloud_user",
      "password": "NOTthisday@@22",
      "host": "localhost",
      "database": "newcloud",
      "port": "5432"
    }
  }

================
File: db.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pg_1 = require("pg");
const poolConfig = {
    user: process.env.DB_USER,
    host: process.env.DB_HOST,
    database: process.env.DB_NAME,
    password: process.env.DB_PASSWORD,
    port: parseInt(process.env.DB_PORT || '5432'),
    options: '-c search_path=newcloud_schema,public'
};
const pool = new pg_1.Pool(poolConfig);
exports.default = pool;

================
File: db.ts
================
import { Pool, PoolConfig } from 'pg';

const poolConfig: PoolConfig = {
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: parseInt(process.env.DB_PORT || '5432'),
  options: '-c search_path=newcloud_schema,public'
};

const pool = new Pool(poolConfig);

export default pool;

================
File: Dockerfile.test
================
FROM node:20

WORKDIR /usr/src/app

COPY package*.json ./
RUN npm install

COPY . .
RUN npm run build

EXPOSE 3001
CMD ["npm", "start"]

================
File: manual-migration.js
================
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: parseInt(process.env.DB_PORT || '5432'),
});

async function addProfilePictureColumn() {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    // Set search_path
    await client.query('SET search_path TO newcloud_schema, public');

    // Check if the column already exists
    const checkColumnQuery = `
      SELECT column_name 
      FROM information_schema.columns 
      WHERE table_schema = 'newcloud_schema' 
      AND table_name = 'users' 
      AND column_name = 'profile_picture_url'
    `;
    const checkResult = await client.query(checkColumnQuery);

    if (checkResult.rows.length === 0) {
      // Add the column if it doesn't exist
      await client.query(`
        ALTER TABLE users 
        ADD COLUMN profile_picture_url VARCHAR(255)
      `);
      console.log('Added profile_picture_url column');

      // Set default value for existing rows
      await client.query(`
        UPDATE users 
        SET profile_picture_url = '/default-avatar.png' 
        WHERE profile_picture_url IS NULL
      `);
      console.log('Set default value for profile_picture_url');
    } else {
      console.log('profile_picture_url column already exists');
    }

    await client.query('COMMIT');
    console.log('Migration completed successfully');
  } catch (err) {
    await client.query('ROLLBACK');
    console.error('Error during migration:', err);
  } finally {
    client.release();
    await pool.end();
  }
}

addProfilePictureColumn();

================
File: migrations/20240311120000_add_profile_picture_url.sql
================
-- In each migration file (e.g., 20240311120000_add_profile_picture_url.sql)
SET search_path TO newcloud_schema, public;

-- Your existing migration SQL follows...
ALTER TABLE users
ADD COLUMN profile_picture_url VARCHAR(255);

UPDATE users SET profile_picture_url = '/default-avatar.png' WHERE profile_picture_url IS NULL;

================
File: package.json
================
{
  "name": "auth-service",
  "version": "1.0.0",
  "main": "dist/server.js",
  "scripts": {
    "start": "node dist/server.js",
    "dev": "nodemon src/server.ts",
    "build": "tsc",
    "watch": "tsc -w",
    "migrate": "node -r dotenv/config ./node_modules/.bin/node-pg-migrate",
    "migrate:up": "node-pg-migrate up",
    "migrate:down": "node-pg-migrate down"
  },
  "dependencies": {
    "auth-service": "file:",
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "express": "^5.0.0",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.1",
    "node-pg-migrate": "^7.6.1"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/cors": "^2.8.12",
    "@types/express": "^4.17.13",
    "@types/jsonwebtoken": "^8.5.5",
    "@types/multer": "^1.4.12",
    "@types/node": "^16.11.6",
    "@types/pg": "^8.11.8",
    "dotenv": "^16.4.5",
    "node-pg-migrate": "^7.6.1",
    "nodemon": "^3.1.0",
    "pg": "^8.12.0",
    "ts-node": "^10.4.0",
    "typescript": "^4.4.4"
  }
}

================
File: run-migration.js
================
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: parseInt(process.env.DB_PORT || '5432'),
});

async function verifyAndCreateSchema() {
  const client = await pool.connect();
  try {
    console.log('Successfully connected to the database');

    // Check search_path
    const searchPathResult = await client.query('SHOW search_path');
    console.log('Current search_path:', searchPathResult.rows[0].search_path);

    // List all schemas
    const allSchemasResult = await client.query(`
      SELECT schema_name 
      FROM information_schema.schemata 
      WHERE schema_name NOT LIKE 'pg_%' AND schema_name != 'information_schema'
    `);
    console.log('Available schemas:', allSchemasResult.rows.map(row => row.schema_name));

    // Check if the schema exists
    const schemaResult = await client.query(`
      SELECT schema_name 
      FROM information_schema.schemata 
      WHERE schema_name = 'newcloud_schema'
    `);
    
    if (schemaResult.rows.length > 0) {
      console.log('newcloud_schema exists');
    } else {
      console.log('newcloud_schema does not exist, attempting to create...');
      await client.query('CREATE SCHEMA IF NOT EXISTS newcloud_schema');
      console.log('newcloud_schema created');
    }

    // Set search_path to include newcloud_schema
    await client.query('SET search_path TO newcloud_schema, public');
    console.log('Set search_path to include newcloud_schema');

    // Check user permissions
    const permissionsResult = await client.query(`
      SELECT has_schema_privilege('${process.env.DB_USER}', 'newcloud_schema', 'CREATE')
    `);
    console.log('User has CREATE permission on newcloud_schema:', permissionsResult.rows[0].has_schema_privilege);

  } catch (err) {
    console.error('Error:', err);
  } finally {
    client.release();
    await pool.end();
  }
}

verifyAndCreateSchema();

================
File: server.js
================
"use strict";
// services/auth/src/server.ts
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dotenv_1 = __importDefault(require("dotenv"));
dotenv_1.default.config();
const express_1 = __importDefault(require("express"));
const cors_1 = __importDefault(require("cors"));
const auth_1 = __importDefault(require("./src/routes/auth"));
const path_1 = __importDefault(require("path"));
const pg_1 = require("pg");
const app = (0, express_1.default)();
const PORT = process.env.PORT || 3001;
app.use((0, cors_1.default)({
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    methods: ['GET', 'POST', 'PUT', 'DELETE'],
    allowedHeaders: ['Content-Type', 'Authorization'],
}));
app.use(express_1.default.json());
app.use('/auth', auth_1.default);
app.listen(PORT, () => {
    console.log(`Auth service running on port ${PORT}`);
});
app.use('/uploads', express_1.default.static(path_1.default.join(__dirname, '..', 'uploads')));
const pool = new pg_1.Pool({
    user: process.env.DB_USER,
    host: process.env.DB_HOST,
    database: process.env.DB_NAME,
    password: String(process.env.DB_PASSWORD),
    port: parseInt(process.env.DB_PORT || '5432'),
});
exports.default = pool;

================
File: src/auth.ts
================
// services/auth/src/auth.ts

import jwt from 'jsonwebtoken';
import { Request, Response, NextFunction } from 'express';

const JWT_SECRET = process.env.JWT_SECRET || 'test@69lol';

interface User {
  id: string;
  username: string;
}

export function generateToken(user: { id: string; username: string }): string {
    return jwt.sign({ id: user.id, username: user.username }, JWT_SECRET, { expiresIn: '1d' });
  }
  
  export function authMiddleware(req: Request, res: Response, next: NextFunction) {
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      return res.status(401).json({ message: 'No token provided' });
    }
  
    const token = authHeader.split(' ')[1];
    if (!token) {
      return res.status(401).json({ message: 'No token provided' });
    }
  
    try {
      const decoded = jwt.verify(token, JWT_SECRET) as { id: string; username: string };
      (req as any).user = decoded;
      next();
    } catch (error) {
      return res.status(401).json({ message: 'Invalid token' });
    }
  }

================
File: src/Dockerfile
================
FROM node:20

WORKDIR /usr/src/app

# Copy package.json and package-lock.json from the parent directory
COPY services/auth/package*.json ./

# Install dependencies
RUN npm install

# Copy the rest of the auth service code
COPY services/auth .

# Typescript is a devDependency, so we need to install it for the build
RUN npm install typescript

# Build the app
RUN npm run build

EXPOSE 3001

# Run the compiled JavaScript
CMD ["node", "dist/server.js"]

RUN mkdir -p /usr/src/app/uploads && chmod 775 /usr/src/app/uploads

================
File: src/routes/auth.ts
================
// services/auth/src/routes/auth.ts

import express from 'express';
import bcrypt from 'bcrypt';
import { generateToken, authMiddleware } from '../auth';
import pool from '../server';
import multer from 'multer';
import path from 'path';
import fs from 'fs';

const router = express.Router();
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, path.join(__dirname, '..', 'uploads'));
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({ storage: storage });

const uploadDir = path.join(__dirname, '..', 'uploads');

if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}


router.post('/upload-avatar', authMiddleware, upload.single('avatar'), async (req, res) => {
  if (!req.file) {
    return res.status(400).json({ message: 'No file uploaded' });
  }

  try {
    const userId = (req as any).user.id;
    const profilePictureUrl = `/uploads/${req.file.filename}`;
    
    // Log the file details for debugging
    console.log('File uploaded:', req.file);
    console.log('Profile picture URL:', profilePictureUrl);
    // Update the user's profile picture URL in the database
    await pool.query('UPDATE users SET profile_picture_url = $1 WHERE id = $2', [profilePictureUrl, userId]);
    
    res.json({ profilePictureUrl });
  } catch (error) {
    console.error('Avatar upload error:', error);
    res.status(500).json({ message: 'Server error during avatar upload' });
  }
});

router.post('/register', async (req, res) => {
    const { username, email, password, firstName, lastName, timezone } = req.body;
  
    if (!username || !password || !firstName || !lastName) {
      return res.status(400).json({ message: 'Username, password, first name, and last name are required' });
    }
  
    try {
      // Check if user already exists
      const userCheck = await pool.query('SELECT * FROM newcloud_schema.users WHERE username = $1', [username]);
      if (userCheck.rows.length > 0) {
        return res.status(400).json({ message: 'Username already exists' });
      }
  
      // Check if email exists if provided
      if (email) {
        const emailCheck = await pool.query('SELECT * FROM newcloud_schema.users WHERE email = $1', [email]);
        if (emailCheck.rows.length > 0) {
          return res.status(400).json({ message: 'Email already in use' });
        }
      }
  
      // Hash password
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(password, salt);
  
      // Get the 'user' role id
      const roleResult = await pool.query('SELECT id FROM newcloud_schema.roles WHERE name = $1', ['user']);
      if (roleResult.rows.length === 0) {
        return res.status(500).json({ message: 'Default role not found' });
      }
      const roleId = roleResult.rows[0].id;
  
      // Insert new user with the 'user' role
      const newUser = await pool.query(
        'INSERT INTO newcloud_schema.users (username, email, password, first_name, last_name, timezone, role_id) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, username',
        [username, email || null, hashedPassword, firstName, lastName, timezone || 'America/Boise', roleId]
      );
  
      const token = generateToken({ id: newUser.rows[0].id, username: newUser.rows[0].username });
      res.status(201).json({ token });
    } catch (error) {
        console.error('Registration error:', error);
        if (error instanceof Error) {
          res.status(500).json({ message: 'Server error during registration', error: error.message });
        } else {
          res.status(500).json({ message: 'Server error during registration' });
        }
      }
  });
  
  router.post('/login', async (req, res) => {
    const { username, password } = req.body;
  
    try {
      const user = await pool.query('SELECT * FROM newcloud_schema.users WHERE username = $1', [username]);
  
      if (user.rows.length === 0) {
        return res.status(400).json({ message: 'Invalid credentials' });
      }
  
      const validPassword = await bcrypt.compare(password, user.rows[0].password);
      if (!validPassword) {
        return res.status(400).json({ message: 'Invalid credentials' });
      }
  
      const token = generateToken({ id: user.rows[0].id, username: user.rows[0].username });
      res.json({ token });
    } catch (error) {
        console.error('Login error:', error);
        if (error instanceof Error) {
          res.status(500).json({ message: 'Server error during login', error: error.message });
        } else {
          res.status(500).json({ message: 'Server error during login' });
        }
      }
  });


/* router.get('/profile', authMiddleware, async (req, res) => {
  try {
    const userId = (req as any).user.id;
    const result = await pool.query('SELECT id, username, email FROM users WHERE id = $1', [userId]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ message: 'User not found' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    console.error('Profile fetch error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});
*/

router.get('/profile', authMiddleware, async (req, res) => {
    try {
      const userId = (req as any).user.id;
      const result = await pool.query(
        'SELECT u.id, u.username, u.email, r.name as role FROM users u JOIN roles r ON u.role_id = r.id WHERE u.id = $1',
        [userId]
      );
      
      if (result.rows.length === 0) {
        return res.status(404).json({ message: 'User not found' });
      }
  
      console.log('Profile data:', result.rows[0]); // Add this line
  
      res.json(result.rows[0]);
    } catch (error) {
      console.error('Profile fetch error:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });

router.put('/profile', authMiddleware, async (req, res) => {
  try {
    const userId = (req as any).user.id;
    const { username, email } = req.body;

    // Check if username already exists
    if (username) {
      const usernameCheck = await pool.query('SELECT id FROM users WHERE username = $1 AND id != $2', [username, userId]);
      if (usernameCheck.rows.length > 0) {
        return res.status(400).json({ message: 'Username already taken' });
      }
    }

    // Update user profile
    const result = await pool.query(
      'UPDATE users SET username = COALESCE($1, username), email = COALESCE($2, email) WHERE id = $3 RETURNING id, username, email',
      [username, email, userId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ message: 'User not found' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    console.error('Profile update error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

router.put('/change-password', authMiddleware, async (req, res) => {
    try {
      const userId = (req as any).user.id;
      const { currentPassword, newPassword } = req.body;
  
      // Fetch the user from the database
      const userResult = await pool.query('SELECT * FROM users WHERE id = $1', [userId]);
      if (userResult.rows.length === 0) {
        return res.status(404).json({ message: 'User not found' });
      }
  
      const user = userResult.rows[0];
  
      // Verify current password
      const isValidPassword = await bcrypt.compare(currentPassword, user.password);
      if (!isValidPassword) {
        return res.status(400).json({ message: 'Current password is incorrect' });
      }
  
      // Hash the new password
      const salt = await bcrypt.genSalt(10);
      const hashedNewPassword = await bcrypt.hash(newPassword, salt);
  
      // Update the password in the database
      await pool.query('UPDATE users SET password = $1 WHERE id = $2', [hashedNewPassword, userId]);
  
      res.json({ message: 'Password updated successfully' });
    } catch (error) {
      console.error('Password change error:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });

  router.post('/upload-avatar', authMiddleware, upload.single('avatar'), async (req, res) => {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }
  
    try {
      const userId = (req as any).user.id;
      const profilePictureUrl = `/uploads/${req.file.filename}`; // This should be a URL, not a file path
      
      await pool.query('UPDATE users SET profile_picture_url = $1 WHERE id = $2', [profilePictureUrl, userId]);
      
      res.json({ profilePictureUrl });
    } catch (error) {
      console.error('Avatar upload error:', error);
      res.status(500).json({ message: 'Server error during avatar upload' });
    }
  });

  const isSiteAdmin = async (req: any, res: any, next: any) => {
    const userId = req.user.id;
    const result = await pool.query(
      'SELECT r.name FROM users u JOIN roles r ON u.role_id = r.id WHERE u.id = $1',
      [userId]
    );
    if (result.rows[0]?.name === 'site_admin') {
      next();
    } else {
      res.status(403).json({ message: 'Access denied' });
    }
  };
  
  // Middleware to check if user is an application admin or site admin
  const isAdmin = async (req: any, res: any, next: any) => {
    const userId = req.user.id;
    const result = await pool.query(
      'SELECT r.name FROM users u JOIN roles r ON u.role_id = r.id WHERE u.id = $1',
      [userId]
    );
    if (['site_admin', 'application_admin'].includes(result.rows[0]?.name)) {
      next();
    } else {
      res.status(403).json({ message: 'Access denied' });
    }
  };
  
  // Route to get all users (admin only)
  router.get('/users', authMiddleware, isAdmin, async (req, res) => {
    try {
      const result = await pool.query('SELECT u.id, u.username, u.email, r.name as role FROM users u JOIN roles r ON u.role_id = r.id');
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching users:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });
  
  // Route to update user role (site admin only)
  router.put('/users/:id/role', authMiddleware, isSiteAdmin, async (req, res) => {
    const { id } = req.params;
    const { role } = req.body;
  
    try {
      const roleResult = await pool.query('SELECT id FROM roles WHERE name = $1', [role]);
      if (roleResult.rows.length === 0) {
        return res.status(400).json({ message: 'Invalid role' });
      }
  
      const roleId = roleResult.rows[0].id;
      await pool.query('UPDATE users SET role_id = $1 WHERE id = $2', [roleId, id]);
      res.json({ message: 'User role updated successfully' });
    } catch (error) {
      console.error('Error updating user role:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });

  router.put('/users/:id/role', authMiddleware, isSiteAdmin, async (req, res) => {
    const { id } = req.params;
    const { role } = req.body;
  
    try {
      // Check if the role is valid
      const validRoles = ['user', 'application_admin', 'site_admin'];
      if (!validRoles.includes(role)) {
        return res.status(400).json({ message: 'Invalid role' });
      }
  
      const roleResult = await pool.query('SELECT id FROM roles WHERE name = $1', [role]);
      if (roleResult.rows.length === 0) {
        return res.status(400).json({ message: 'Invalid role' });
      }
  
      const roleId = roleResult.rows[0].id;
      await pool.query('UPDATE users SET role_id = $1 WHERE id = $2', [roleId, id]);
      res.json({ message: 'User role updated successfully' });
    } catch (error) {
      console.error('Error updating user role:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });

  router.post('/upload-avatar', authMiddleware, upload.single('avatar'), async (req, res) => {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }
  
    try {
      const userId = (req as any).user.id;
      const profilePictureUrl = `/uploads/${req.file.filename}`;
      
      await pool.query('UPDATE users SET profile_picture_url = $1 WHERE id = $2', [profilePictureUrl, userId]);
      
      res.json({ profilePictureUrl });
    } catch (error) {
      console.error('Avatar upload error:', error);
      res.status(500).json({ message: 'Server error during avatar upload' });
    }
  });
  
  // Update the existing /profile PUT route
  router.put('/profile', authMiddleware, async (req, res) => {
    try {
      const userId = (req as any).user.id;
      const { firstName, lastName, email, timezone } = req.body;
  
      const result = await pool.query(
        'UPDATE users SET first_name = $1, last_name = $2, email = $3, timezone = $4 WHERE id = $5 RETURNING id, username, email, first_name, last_name, timezone, profile_picture_url',
        [firstName, lastName, email, timezone, userId]
      );
  
      if (result.rows.length === 0) {
        return res.status(404).json({ message: 'User not found' });
      }
  
      res.json(result.rows[0]);
    } catch (error) {
      console.error('Profile update error:', error);
      res.status(500).json({ message: 'Server error during profile update' });
    }
  });

  router.post('/upload-avatar', authMiddleware, upload.single('avatar'), async (req, res) => {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }
  
    try {
      const userId = (req as any).user.id;
      const profilePictureUrl = `/uploads/${req.file.filename}`;
      
      await pool.query('UPDATE users SET profile_picture_url = $1 WHERE id = $2', [profilePictureUrl, userId]);
      
      res.json({ profilePictureUrl });
    } catch (error) {
      console.error('Avatar upload error:', error);
      res.status(500).json({ message: 'Server error during avatar upload' });
    }
  });

export default router;

================
File: src/server.ts
================
// services/auth/src/server.ts
import express from 'express';
import cors from 'cors';
import authRoutes from './routes/auth';
import path from 'path';
import { Pool } from 'pg';
import dotenv from 'dotenv';

const app = express();
const PORT = process.env.PORT || 3001;

dotenv.config({ path: path.resolve(__dirname, '../../.env') });

app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization'],
}));

app.use(express.json());

app.use('/auth', authRoutes);

app.listen(PORT, () => {
  console.log(`Auth service running on port ${PORT}`);
});

app.use('/uploads', express.static(path.join(__dirname, '..', 'uploads')))

const pool = new Pool({
  user: process.env.DB_USER || 'newcloud_user',
  host: process.env.DB_HOST || 'localhost',
  database: process.env.DB_NAME || 'newcloud',
  password: process.env.DB_PASSWORD,
  port: parseInt(process.env.DB_PORT || '5432'),
  options: '-c search_path=newcloud_schema,public'
});

// Add this for debugging
pool.on('error', (err) => {
  console.error('Unexpected error on idle client', err);
  process.exit(-1);
});

export default pool;

console.log('Database connection details:');
console.log('DB_USER:', process.env.DB_USER);
console.log('DB_HOST:', process.env.DB_HOST);
console.log('DB_NAME:', process.env.DB_NAME);
console.log('DB_PASSWORD:', process.env.DB_PASSWORD ? '[REDACTED]' : 'Not set');
console.log('DB_PORT:', process.env.DB_PORT);

================
File: test-db-connection.js
================
const path = require('path');
require('dotenv').config();
const migrate = require('node-pg-migrate').default;

const dbConfig = {
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '5432'),
  database: process.env.DB_NAME,
};

const databaseUrl = `postgres://${dbConfig.user}:${encodeURIComponent(dbConfig.password)}@${dbConfig.host}:${dbConfig.port}/${dbConfig.database}?search_path=newcloud_schema,public`;

async function runMigration() {
  try {
    await migrate({
      databaseUrl: databaseUrl,
      schema: 'newcloud_schema',
      migrationsTable: 'pgmigrations',
      dir: 'migrations',
      direction: 'up',
      count: Infinity,
    });
    console.log('Migration completed successfully');
  } catch (error) {
    console.error('Migration failed:', error);
  }
}

runMigration();

================
File: tsconfig.json
================
{
    "compilerOptions": {
      "target": "es6",
      "module": "commonjs",
      "outDir": "./dist",
      "rootDir": "./src",
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true,
      "resolveJsonModule": true,
      "typeRoots": ["./node_modules/@types", "./src/types"]
    },
    "include": ["src/**/*", "src/server.ts"],
    "exclude": ["node_modules"]
  }
