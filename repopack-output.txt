This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-09-12T15:27:04.013Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
.trunk/.gitignore
.trunk/configs/.hadolint.yaml
.trunk/configs/.markdownlint.yaml
.trunk/configs/.yamllint.yaml
.trunk/trunk.yaml
client/app/_tests_/client.test.js
client/app/.dockerignore
client/app/.eslintrc.json
client/app/.gitignore
client/app/Dockerfile
client/app/next.config.js
client/app/package.json
client/app/postcss.config.mjs
client/app/README.md
client/app/src/components/DashboardButton.tsx
client/app/src/components/Header.tsx
client/app/src/components/Layout.tsx
client/app/src/components/LogoutButton.tsx
client/app/src/components/ProtectedRoute.tsx
client/app/src/contexts/AuthContext.tsx
client/app/src/pages/_app.tsx
client/app/src/pages/admin/users.tsx
client/app/src/pages/dashboard.tsx
client/app/src/pages/index.tsx
client/app/src/pages/register.tsx
client/app/src/pages/settings.tsx
client/app/src/styles/globals.css
client/app/src/styles/page.tsx
client/app/src/utils/api.ts
client/app/src/utils/auth.ts
client/app/tailwind.config.ts
client/app/tsconfig.json
docker-compose.yml
Dockerfile
init.sql
next-config-issue.txt
notes.txt
package.json
README.md
services/auth/_tests_/auth.test.js
services/auth/check-permissions.js
services/auth/database.json
services/auth/db.ts
services/auth/dist/auth.js
services/auth/dist/db.js
services/auth/dist/routes/auth.js
services/auth/dist/server.js
services/auth/Dockerfile
services/auth/manual-migration.js
services/auth/migrations/20240311120000_add_profile_picture_url.sql
services/auth/package.json
services/auth/repopack-output.txt
services/auth/run-migration.js
services/auth/src/auth.ts
services/auth/src/routes/auth.ts
services/auth/src/server.ts
services/auth/test-db-connection.js
services/auth/tsconfig.json

================================================================
Repository Files
================================================================

================
File: .gitignore
================
node_modules
.env
.next
*.log

================
File: .trunk/.gitignore
================
*out
*logs
*actions
*notifications
*tools
plugins
user_trunk.yaml
user.yaml
tmp

================
File: .trunk/configs/.hadolint.yaml
================
# Following source doesn't work in most setups
ignored:
  - SC1090
  - SC1091

================
File: .trunk/configs/.markdownlint.yaml
================
# Prettier friendly markdownlint config (all formatting rules disabled)
extends: markdownlint/style/prettier

================
File: .trunk/configs/.yamllint.yaml
================
rules:
  quoted-strings:
    required: only-when-needed
    extra-allowed: ["{|}"]
  key-duplicates: {}
  octal-values:
    forbid-implicit-octal: true

================
File: .trunk/trunk.yaml
================
# This file controls the behavior of Trunk: https://docs.trunk.io/cli
# To learn more about the format of this file, see https://docs.trunk.io/reference/trunk-yaml
version: 0.1
cli:
  version: 1.22.5
# Trunk provides extensibility via plugins. (https://docs.trunk.io/plugins)
plugins:
  sources:
    - id: trunk
      ref: v1.6.2
      uri: https://github.com/trunk-io/plugins
# Many linters and tools depend on runtimes - configure them here. (https://docs.trunk.io/runtimes)
runtimes:
  enabled:
    - node@18.12.1
    - python@3.10.8
# This is the section where you manage your linters. (https://docs.trunk.io/check/configuration)
lint:
  disabled:
    - git-diff-check
    - prettier
  enabled:
    - checkov@3.2.250
    - hadolint@2.12.0
    - markdownlint@0.41.0
    - osv-scanner@1.8.4
    - trufflehog@3.81.10
    - yamllint@1.35.1

================
File: client/app/_tests_/client.test.js
================
// services/auth/__tests__/auth.test.js

describe('Auth Service', () => {
    test('placeholder test', () => {
      expect(true).toBe(true);
    });
  });

================
File: client/app/.dockerignore
================
node_modules
.next

================
File: client/app/.eslintrc.json
================
{
  "extends": ["next/core-web-vitals"],
  "parser": "@babel/eslint-parser",
  "parserOptions": {
    "requireConfigFile": false,
    "babelOptions": {
      "presets": ["next/babel"]
    }
  }
}

================
File: client/app/.gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: client/app/Dockerfile
================
FROM node:20

WORKDIR /usr/src/app

# Copy package.json and package-lock.json
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy the rest of the client code
COPY . .

# Build the Next.js app
RUN npm run build

# Expose the port the app runs on
EXPOSE 3000

# Command to run the application
CMD ["npm", "start"]

================
File: client/app/next.config.js
================
/** @type {import('next').NextConfig} */
const nextConfig = {
    reactStrictMode: true,
  };

  module.exports = nextConfig;

================
File: client/app/package.json
================
{
  "name": "new-cloud-client",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "jest",
    "test:watch": "jest --watch"
  },
  "engines": {
    "node": "20.17.0"
  },
  "dependencies": {
    "@heroicons/react": "^2.1.5",
    "@tanstack/react-query": "^4.29.5",
    "axios": "^1.7.7",
    "babel": "^7.25.0",
    "new-cloud-client": "file:",
    "next": "^14.2.8",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@babel/eslint-parser": "^7.22.5",
    "@babel/preset-env": "^7.22.5",
    "@babel/preset-react": "^7.22.5",
    "@babel/preset-typescript": "^7.22.5",
    "@testing-library/jest-dom": "^6.5.0",
    "@testing-library/react": "^14.0.0",
    "@types/babel__core": "^7.20.5",
    "@types/babel__generator": "^7.6.8",
    "@types/babel__template": "^7.4.4",
    "@types/babel__traverse": "^7.20.6",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/json-schema": "^7.0.15",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/node": "^22.5.4",
    "@types/react": "^18.2.6",
    "@types/react-dom": "^18.2.4",
    "autoprefixer": "^10.4.14",
    "babel": "^6.23.0",
    "eslint": "^8.40.0",
    "eslint-config-next": "^14.2.8",
    "jest": "^29.5.0",
    "postcss": "^8.4.23",
    "tailwindcss": "^3.3.2",
    "typescript": "^5.6.2"
  }
}

================
File: client/app/postcss.config.mjs
================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

================
File: client/app/README.md
================
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

================
File: client/app/src/components/DashboardButton.tsx
================
import React from 'react';
import { useAuth } from '../contexts/AuthContext';
import { useRouter } from 'next/router';

const DashboardButton: React.FC = () => {
  const { logout } = useAuth();
  const router = useRouter();

  const handleLogout = () => {
    logout();
    router.push('/dashboard');
  };

  return (
    <button onClick={handleLogout} className="bg-blue-500 text-white px-4 py-2 rounded">
      Dashboard
    </button>
  );
};

export default DashboardButton;

================
File: client/app/src/components/Header.tsx
================
import React from 'react';
import Link from 'next/link';
import { useAuth } from '../contexts/AuthContext';
import { useRouter } from 'next/router';
import Image from 'next/image';

const Header: React.FC = () => {
  const { user, logout } = useAuth();
  const router = useRouter();

  const handleLogout = () => {
    logout();
    router.push('/');
  };

  return (
    <header className="bg-white shadow-md fixed top-0 left-0 right-0 z-10">
      <nav className="container mx-auto px-6 py-3">
        <div className="flex justify-between items-center">
          <div className="text-xl font-semibold text-gray-700">
            <Link href="/dashboard">New Cloud</Link>
          </div>
          {user && (
            <div className="flex items-center space-x-4">
              <Link href="/dashboard" className="text-gray-800 hover:text-blue-500">
                Dashboard
              </Link>
              <Link href="/settings" className="text-gray-800 hover:text-blue-500">
                Settings
              </Link>
              {user.role === 'site_admin' && (
                <Link href="/admin/users" className="text-gray-800 hover:text-blue-500">
                  Manage Users
                </Link>
              )}
              <button
                onClick={handleLogout}
                className="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded"
              >
                Logout
              </button>
              <div className="relative group">
                <Image
                  src={user.profilePictureUrl || '/default-avatar.png'}
                  alt="Profile"
                  width={40}
                  height={40}
                  className="rounded-full cursor-pointer"
                />
              </div>
            </div>
          )}
        </div>
      </nav>
    </header>
  );
};

export default Header;

================
File: client/app/src/components/Layout.tsx
================
// src/components/Layout.tsx
import React from 'react';
import Header from './Header';

interface LayoutProps {
  children: React.ReactNode;
}

const Layout: React.FC<LayoutProps> = ({ children }) => {
  return (
    <div className="min-h-screen bg-gray-100">
      <Header />
      <main className="pt-16 pb-8 px-4 sm:px-6 lg:px-8">
        {children}
      </main>
    </div>
  );
};

export default Layout;

================
File: client/app/src/components/LogoutButton.tsx
================
// client/src/components/LogoutButton.tsx

import React from 'react';
import { useAuth } from '../contexts/AuthContext';
import { useRouter } from 'next/router';

const LogoutButton: React.FC = () => {
  const { logout } = useAuth();
  const router = useRouter();

  const handleLogout = () => {
    logout();
    router.push('/login');
  };

  return (
    <button onClick={handleLogout} className="bg-red-500 text-white px-4 py-2 rounded">
      Logout
    </button>
  );
};

export default LogoutButton;

================
File: client/app/src/components/ProtectedRoute.tsx
================
// client/src/components/ProtectedRoute.tsx

import { useEffect } from 'react';
import { useRouter } from 'next/router';
import { useAuth } from '../contexts/AuthContext';

interface ProtectedRouteProps {
  children: React.ReactNode;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { isAuthenticated } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!isAuthenticated) {
      router.push('/');
    }
  }, [isAuthenticated, router]);

  if (!isAuthenticated) {
    return null; // or a loading spinner
  }

  return <>{children}</>;
};

export default ProtectedRoute;

================
File: client/app/src/contexts/AuthContext.tsx
================
import React, { createContext, useState, useContext, useEffect } from 'react';
import { setToken, getToken, removeToken } from '../utils/auth';
import api from '../utils/api';

// Define the User type here instead of importing it
interface User {
  id: string;
  username: string;
  email: string;
  firstName: string;
  lastName: string;
  timezone: string;
  role: string;
  profilePictureUrl?: string;
}

interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  login: (token: string) => Promise<void>;
  logout: () => void;
  updateUser: (user: User) => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    const token = getToken();
    if (token) {
      fetchUser();
    }
  }, []);

  const fetchUser = async () => {
    try {
      const response = await api.get<User>('/auth/profile');
      console.log('Fetched user:', response.data);
      setUser(response.data);
    } catch (error) {
      console.error('Failed to fetch user', error);
      removeToken();
    }
  };

  const login = async (token: string) => {
    setToken(token);
    await fetchUser();
  };

  const logout = () => {
    removeToken();
    setUser(null);
  };

  const updateUser = (updatedUser: User) => {
    setUser(updatedUser);
  };

  console.log('Current user:', user);

  return (
    <AuthContext.Provider value={{ user, isAuthenticated: !!user, login, logout, updateUser }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

================
File: client/app/src/pages/_app.tsx
================
import { useEffect } from 'react';
import type { AppProps } from 'next/app';
import { AuthProvider } from '../contexts/AuthContext';
import Layout from '../components/Layout';
import '../styles/globals.css';

function MyApp({ Component, pageProps }: AppProps) {
  useEffect(() => {
    // Check for dark mode preference
    if (localStorage.getItem('darkMode') === 'true') {
      document.documentElement.classList.add('dark');
    }
  }, []);

  return (
    <AuthProvider>
      <Layout>
        <Component {...pageProps} />
      </Layout>
    </AuthProvider>
  );
}

export default MyApp;

================
File: client/app/src/pages/admin/users.tsx
================
// src/pages/admin/users.tsx

import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import { useAuth } from '../../contexts/AuthContext';
import api from '../../utils/api';

interface User {
  id: string;
  username: string;
  email: string;
  role: string;
}

export default function UserManagement() {
  const [users, setUsers] = useState<User[]>([]);
  const { user } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (user && user.role === 'site_admin') {
      fetchUsers();
    } else {
      router.push('/dashboard');
    }
  }, [user, router]);

  const fetchUsers = async () => {
    try {
      const response = await api.get<User[]>('/auth/users');
      setUsers(response.data);
    } catch (error) {
      console.error('Failed to fetch users', error);
    }
  };

  const updateUserRole = async (userId: string, newRole: string) => {
    try {
      await api.put(`/auth/users/${userId}/role`, { role: newRole });
      fetchUsers(); // Refresh the user list
    } catch (error) {
      console.error('Failed to update user role', error);
    }
  };

  return (
    <div className="min-h-screen bg-gray-100 py-6 flex flex-col justify-center sm:py-12">
      <div className="relative py-3 sm:max-w-xl sm:mx-auto">
        <div className="relative px-4 py-10 bg-white shadow-lg sm:rounded-3xl sm:p-20">
          <h1 className="text-2xl font-semibold mb-6">User Management</h1>
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Username</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Email</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Role</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {users.map((user) => (
                <tr key={user.id}>
                  <td className="px-6 py-4 whitespace-nowrap">{user.username}</td>
                  <td className="px-6 py-4 whitespace-nowrap">{user.email}</td>
                  <td className="px-6 py-4 whitespace-nowrap">{user.role}</td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <select
                      value={user.role}
                      onChange={(e) => updateUserRole(user.id, e.target.value)}
                      className="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                    >
                      <option value="user">User</option>
                      <option value="application_admin">Application Admin</option>
                      <option value="site_admin">Site Admin</option>
                    </select>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
}

================
File: client/app/src/pages/dashboard.tsx
================
// src/pages/dashboard.tsx

import { useEffect } from 'react';
import { useRouter } from 'next/router';
import Link from 'next/link';
import { useAuth } from '../contexts/AuthContext';
import ProtectedRoute from '../components/ProtectedRoute';

export default function Dashboard() {
  const { user, logout } = useAuth();
  const router = useRouter();

  useEffect(() => {
    console.log('Dashboard user:', user);
  }, [user]);

  const handleLogout = () => {
    logout();
    router.push('/');
  };

  return (
    <ProtectedRoute>
        <main>
          <div className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
            <div className="px-4 py-6 sm:px-0">
              <div className="border-4 border-dashed border-gray-200 rounded-lg h-96">
                <div className="flex flex-col items-center justify-center h-full">
                  <h2 className="text-2xl font-semibold mb-4">Welcome to Your Dashboard</h2>
                  <p className="mb-4">Here you can access all New Cloud services.</p>
                  <Link href="/settings" className="text-indigo-600 hover:text-indigo-500">
                    View/Update Your Profile
                  </Link>
                </div>
              </div>
            </div>
          </div>
        </main>
    </ProtectedRoute>
  );
}

================
File: client/app/src/pages/index.tsx
================
import { useState } from 'react';
import { useRouter } from 'next/router';
import Link from 'next/link';
import { useAuth } from '../contexts/AuthContext';
import api from '../utils/api';

export default function Home() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const router = useRouter();
  const { login } = useAuth();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    try {
      const response = await api.post('/auth/login', { username, password });
      login(response.data.token);
      router.push('/dashboard');
    } catch (err) {
      setError('Invalid username or password');
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            Welcome to New Cloud
          </h2>
        </div>
        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          <input type="hidden" name="remember" value="true" />
          <div className="rounded-md shadow-sm -space-y-px">
            <div>
              <label htmlFor="username" className="sr-only">Username</label>
              <input
                id="username"
                name="username"
                type="text"
                required
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-t-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
                placeholder="Username"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
              />
            </div>
            <div>
              <label htmlFor="password" className="sr-only">Password</label>
              <input
                id="password"
                name="password"
                type="password"
                required
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-b-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
                placeholder="Password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
              />
            </div>
          </div>

          {error && <div className="text-red-500 text-sm">{error}</div>}

          <div>
            <button
              type="submit"
              className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
            >
              Sign in
            </button>
          </div>
        </form>
        <div className="text-center">
          <Link href="/register" className="font-medium text-indigo-600 hover:text-indigo-500">
            Do you need an account? Register here
          </Link>
        </div>
      </div>
    </div>
  );
}

================
File: client/app/src/pages/register.tsx
================
import { useState } from 'react';
import { useRouter } from 'next/router';
import Link from 'next/link';
import { useAuth } from '../contexts/AuthContext';
import api from '../utils/api';

const timezones = [
  'America/Boise',
  'America/New_York',
  'America/Chicago',
  'America/Denver',
  'America/Los_Angeles',
  // Add more timezones as needed
];

export default function Register() {
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [timezone, setTimezone] = useState('America/Boise');
  const [error, setError] = useState('');
  const router = useRouter();
  const { login } = useAuth();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    if (password !== confirmPassword) {
      setError("Passwords don't match");
      return;
    }

    try {
      const response = await api.post('/auth/register', {
        username,
        email,
        password: String(password), // Explicitly convert to string
        firstName,
        lastName,
        timezone
      });
      login(response.data.token);
      router.push('/dashboard');
    } catch (err: any) {
      console.error('Registration error:', err.response?.data || err.message);
      if (err.response?.data?.error) {
        setError(`Registration failed: ${err.response.data.error}`);
      } else if (err.response?.data?.message) {
        setError(err.response.data.message);
      } else {
        setError('Registration failed. Please try again.');
      }
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            Register for New Cloud
          </h2>
        </div>
        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          <div className="rounded-md shadow-sm -space-y-px">
            <div>
              <input
                id="username"
                name="username"
                type="text"
                required
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-t-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
                placeholder="Username"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
              />
            </div>
            <div>
              <input
                id="email"
                name="email"
                type="email"
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
                placeholder="Email (optional)"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
              />
            </div>
            <div>
              <input
                id="firstName"
                name="firstName"
                type="text"
                required
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
                placeholder="First Name"
                value={firstName}
                onChange={(e) => setFirstName(e.target.value)}
              />
            </div>
            <div>
              <input
                id="lastName"
                name="lastName"
                type="text"
                required
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
                placeholder="Last Name"
                value={lastName}
                onChange={(e) => setLastName(e.target.value)}
              />
            </div>
            <div>
              <select
                id="timezone"
                name="timezone"
                required
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
                value={timezone}
                onChange={(e) => setTimezone(e.target.value)}
              >
                {timezones.map((tz) => (
                  <option key={tz} value={tz}>{tz}</option>
                ))}
              </select>
            </div>
            <div>
              <input
                id="password"
                name="password"
                type="password"
                required
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
                placeholder="Password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
              />
            </div>
            <div>
              <input
                id="confirm-password"
                name="confirm-password"
                type="password"
                required
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-b-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
                placeholder="Confirm Password"
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
              />
            </div>
          </div>

          {error && <div className="text-red-500 text-sm">{error}</div>}

          <div>
            <button
              type="submit"
              className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
            >
              Register
            </button>
          </div>
        </form>
        <div className="text-center">
          <Link href="/" className="font-medium text-indigo-600 hover:text-indigo-500">
            Already have an account? Sign in here
          </Link>
        </div>
      </div>
    </div>
  );
}

================
File: client/app/src/pages/settings.tsx
================
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import { useAuth } from '../contexts/AuthContext';
import api from '../utils/api';
import ProtectedRoute from '../components/ProtectedRoute';
import Image from 'next/image';

interface UserProfile {
  id: string;
  username: string;
  email: string;
  firstName: string;
  lastName: string;
  timezone: string;
  profilePictureUrl: string;
  role: string;
}

const Settings: React.FC = () => {
  const [profile, setProfile] = useState<UserProfile | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState('');
  const [successMessage, setSuccessMessage] = useState('');
  const [currentPassword, setCurrentPassword] = useState('');
  const [newPassword, setNewPassword] = useState('');
  const [confirmNewPassword, setConfirmNewPassword] = useState('');
  const [darkMode, setDarkMode] = useState(false);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [uploadedPictures, setUploadedPictures] = useState<string[]>([]);
  const router = useRouter();
  const { user, updateUser } = useAuth();

  useEffect(() => {
    fetchProfile();
    const savedDarkMode = localStorage.getItem('darkMode') === 'true';
    setDarkMode(savedDarkMode);
    if (savedDarkMode) {
      document.documentElement.classList.add('dark');
    }
  }, []);

  const fetchProfile = async () => {
    try {
      setIsLoading(true);
      const response = await api.get<UserProfile>('/auth/profile');
      setProfile(response.data);
      setUploadedPictures([response.data.profilePictureUrl]);
      setError('');
    } catch (err) {
      console.error('Failed to fetch profile', err);
      setError('Failed to fetch profile. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  const handleProfileUpdate = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!profile) return;

    try {
      const response = await api.put<UserProfile>('/auth/profile', profile);
      setProfile(response.data);
      updateUser(response.data);
      setSuccessMessage('Profile updated successfully');
    } catch (err) {
      console.error('Failed to update profile', err);
      setError('Failed to update profile');
    }
  };

  const handlePasswordChange = async (e: React.FormEvent) => {
    e.preventDefault();
    if (newPassword !== confirmNewPassword) {
      setError("New passwords don't match");
      return;
    }

    try {
      await api.put('/auth/change-password', { currentPassword, newPassword });
      setSuccessMessage('Password changed successfully');
      setCurrentPassword('');
      setNewPassword('');
      setConfirmNewPassword('');
    } catch (err) {
      console.error('Failed to change password', err);
      setError('Failed to change password. Please try again.');
    }
  };

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      setSelectedFile(e.target.files[0]);
    }
  };

  const handleAvatarUpload = async () => {
    if (selectedFile && profile) {
      const formData = new FormData();
      formData.append('avatar', selectedFile);
      try {
        const response = await api.post<{ profilePictureUrl: string }>('/auth/upload-avatar', formData, {
          headers: { 'Content-Type': 'multipart/form-data' }
        });
        const newProfilePictureUrl = response.data.profilePictureUrl;
        setUploadedPictures(prev => [...prev, newProfilePictureUrl].slice(-3));
        setSelectedFile(null);
        setSuccessMessage('Avatar uploaded successfully');
      } catch (err) {
        console.error('Failed to upload avatar', err);
        setError('Failed to upload avatar');
      }
    }
  };

  const handleSetProfilePicture = async (pictureUrl: string) => {
    try {
      await api.put('/auth/set-profile-picture', { profilePictureUrl: pictureUrl });
      setProfile(prev => prev ? { ...prev, profilePictureUrl: pictureUrl } : null);
      updateUser({
        ...user!,
        profilePictureUrl: pictureUrl
      });
      setUploadedPictures(prev => [pictureUrl, ...prev.filter(url => url !== pictureUrl)].slice(0, 3));
      setSuccessMessage('Profile picture updated successfully');
    } catch (err) {
      console.error('Failed to set profile picture', err);
      setError('Failed to set profile picture');
    }
  };

  const handleDeletePicture = async (pictureUrl: string) => {
    try {
      await api.delete(`/auth/delete-picture`, { data: { pictureUrl } });
      setUploadedPictures(prev => prev.filter(url => url !== pictureUrl));
      setSuccessMessage('Picture deleted successfully');
    } catch (err) {
      console.error('Failed to delete picture', err);
      setError('Failed to delete picture');
    }
  };

  const handleDarkModeToggle = () => {
    const newDarkMode = !darkMode;
    setDarkMode(newDarkMode);
    localStorage.setItem('darkMode', newDarkMode.toString());
    if (newDarkMode) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  };

  if (isLoading) {
    return (
      <ProtectedRoute>
        <div className="min-h-screen flex items-center justify-center bg-gray-100 dark:bg-gray-900">
          <p className="text-2xl font-semibold text-gray-900 dark:text-gray-100">Loading...</p>
        </div>
      </ProtectedRoute>
    );
  }

  return (
    <ProtectedRoute>
      <div className="min-h-screen bg-gray-100 dark:bg-gray-900">
        <main className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
          {error && <p className="text-red-500 mb-4">{error}</p>}
          {successMessage && <p className="text-green-500 mb-4">{successMessage}</p>}
          {profile && (
            <div className="space-y-8">
              {/* Profile Information Form */}
              <form onSubmit={handleProfileUpdate} className="bg-white dark:bg-gray-800 shadow-md rounded px-8 pt-6 pb-8 mb-4">
                <h2 className="text-2xl font-bold mb-4 text-gray-900 dark:text-gray-100">Profile Information</h2>
                <div className="mb-4">
                  <label className="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2" htmlFor="username">
                    Username
                  </label>
                  <input
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 dark:text-gray-300 dark:bg-gray-700 leading-tight focus:outline-none focus:shadow-outline"
                    id="username"
                    type="text"
                    value={profile.username}
                    onChange={(e) => setProfile({ ...profile, username: e.target.value })}
                  />
                </div>
                <div className="mb-4">
                  <label className="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2" htmlFor="email">
                    Email
                  </label>
                  <input
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 dark:text-gray-300 dark:bg-gray-700 leading-tight focus:outline-none focus:shadow-outline"
                    id="email"
                    type="email"
                    value={profile.email}
                    onChange={(e) => setProfile({ ...profile, email: e.target.value })}
                  />
                </div>
                <div className="flex items-center justify-between">
                  <button
                    className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
                    type="submit"
                  >
                    Update Profile
                  </button>
                </div>
              </form>

              {/* Password Change Form */}
              <form onSubmit={handlePasswordChange} className="bg-white dark:bg-gray-800 shadow-md rounded px-8 pt-6 pb-8 mb-4">
                <h2 className="text-2xl font-bold mb-4 text-gray-900 dark:text-gray-100">Change Password</h2>
                <div className="mb-4">
                  <label className="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2" htmlFor="currentPassword">
                    Current Password
                  </label>
                  <input
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 dark:text-gray-300 dark:bg-gray-700 leading-tight focus:outline-none focus:shadow-outline"
                    id="currentPassword"
                    type="password"
                    value={currentPassword}
                    onChange={(e) => setCurrentPassword(e.target.value)}
                  />
                </div>
                <div className="mb-4">
                  <label className="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2" htmlFor="newPassword">
                    New Password
                  </label>
                  <input
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 dark:text-gray-300 dark:bg-gray-700 leading-tight focus:outline-none focus:shadow-outline"
                    id="newPassword"
                    type="password"
                    value={newPassword}
                    onChange={(e) => setNewPassword(e.target.value)}
                  />
                </div>
                <div className="mb-6">
                  <label className="block text-gray-700 dark:text-gray-300 text-sm font-bold mb-2" htmlFor="confirmNewPassword">
                    Confirm New Password
                  </label>
                  <input
                    className="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 dark:text-gray-300 dark:bg-gray-700 leading-tight focus:outline-none focus:shadow-outline"
                    id="confirmNewPassword"
                    type="password"
                    value={confirmNewPassword}
                    onChange={(e) => setConfirmNewPassword(e.target.value)}
                  />
                </div>
                <div className="flex items-center justify-between">
                  <button
                    className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
                    type="submit"
                  >
                    Change Password
                  </button>
                </div>
              </form>

              {/* Profile Picture Section */}
              <div className="bg-white dark:bg-gray-800 shadow-md rounded px-8 pt-6 pb-8 mb-4">
                <h2 className="text-2xl font-bold mb-4 text-gray-900 dark:text-gray-100">Profile Picture</h2>
                <div className="flex flex-wrap">
                  {/* Current Profile Picture */}
                  <div className="w-1/3 pr-4">
                    <h3 className="text-lg font-semibold mb-2">Current Picture</h3>
                    <Image
                      src={user?.profilePictureUrl
                        ? `${process.env.NEXT_PUBLIC_API_URL}${user.profilePictureUrl}`
                        : '/default-avatar.png'  // Provide a path to a default avatar image
                      }
                      alt="Profile"
                      width={200}
                      height={200}
                      className="rounded-full"
                    />
                  </div>
                  {/* Other Pictures */}
                  <div className="w-2/3">
                    <h3 className="text-lg font-semibold mb-2">Other Pictures</h3>
                    <div className="flex flex-wrap">
                      {uploadedPictures.filter(url => url !== profile.profilePictureUrl).map((pictureUrl, index) => (
                        <div key={index} className="relative m-2">
                          <Image
                            src={user?.profilePictureUrl
                              ? `${process.env.NEXT_PUBLIC_API_URL}${user.profilePictureUrl}`
                              : '/default-avatar.png'  // Provide a path to a default avatar image
                            }
                            alt={`Uploaded ${index + 1}`}
                            width={100}
                            height={100}
                            className="rounded-md"
                          />
                          <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity">
                            <button
                              onClick={() => handleSetProfilePicture(pictureUrl)}
                              className="bg-blue-500 text-white px-2 py-1 rounded text-sm mr-2"
                            >
                              Set as Profile
                            </button>
                            <button
                              onClick={() => handleDeletePicture(pictureUrl)}
                              className="bg-red-500 text-white px-2 py-1 rounded text-sm"
                            >
                              Delete
                            </button>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
                {/* Upload New Picture */}
                <div className="mt-4">
                  <input
                    type="file"
                    accept="image/*"
                    onChange={handleFileSelect}
                    className="mb-2"
                  />
                  <button
                    onClick={handleAvatarUpload}
                    disabled={!selectedFile}
                    className="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline disabled:opacity-50"
                  >
                    Upload New Picture
                  </button>
                </div>
              </div>

              {/* Dark Mode Toggle */}
              <div className="bg-white dark:bg-gray-800 shadow-md rounded px-8 pt-6 pb-8 mb-4">
                <h2 className="text-2xl font-bold mb-4 text-gray-900 dark:text-gray-100">Application Settings</h2>
                <div className="flex items-center justify-between">
                  <span className="text-gray-700 dark:text-gray-300">Dark Mode</span>
                  <label className="switch">
                    <input
                      type="checkbox"
                      checked={darkMode}
                      onChange={handleDarkModeToggle}
                    />
                    <span className="slider round"></span>
                  </label>
                </div>
              </div>
            </div>
          )}
        </main>
      </div>
    </ProtectedRoute>
  )
};
export default Settings;

================
File: client/app/src/styles/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

/* Add these styles at the end of the file */
.switch {
  position: relative;
  display: inline-block;
  width: 60px;
  height: 34px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .4s;
}

.slider:before {
  position: absolute;
  content: "";
  height: 26px;
  width: 26px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  transition: .4s;
}

input:checked + .slider {
  background-color: #2196F3;
}

input:focus + .slider {
  box-shadow: 0 0 1px #2196F3;
}

input:checked + .slider:before {
  transform: translateX(26px);
}

.slider.round {
  border-radius: 34px;
}

.slider.round:before {
  border-radius: 50%;
}

================
File: client/app/src/styles/page.tsx
================
import Head from 'next/head'

export default function Home() {
  return (
    <div className="flex flex-col items-center justify-center min-h-screen py-2">
      <Head>
        <title>New Cloud</title>
        <meta name="description" content="New Cloud application" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className="flex flex-col items-center justify-center w-full flex-1 px-20 text-center">
        <h1 className="text-6xl font-bold">
          Welcome to <span className="text-blue-600">New Cloud</span>
        </h1>
        <p className="mt-3 text-2xl">
          Your powerful cloud application
        </p>
      </main>
    </div>
  )
}

================
File: client/app/src/utils/api.ts
================
// client/src/utils/api.ts

import axios from 'axios';
import { getToken } from './auth';

const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

const api = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

api.interceptors.request.use((config) => {
  const token = getToken();
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export default api;

================
File: client/app/src/utils/auth.ts
================
// client/src/utils/auth.ts

export function setToken(token: string): void {
    if (typeof window !== 'undefined') {
      localStorage.setItem('token', token);
    }
  }
  
  export function getToken(): string | null {
    if (typeof window !== 'undefined') {
      return localStorage.getItem('token');
    }
    return null;
  }
  
  export function removeToken(): void {
    if (typeof window !== 'undefined') {
      localStorage.removeItem('token');
    }
  }
  
  export function isAuthenticated(): boolean {
    if (typeof window !== 'undefined') {
      return !!localStorage.getItem('token');
    }
    return false;
  }

================
File: client/app/tailwind.config.ts
================
import type { Config } from "tailwindcss";

const config: Config = {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
  darkMode: 'class',
};

export default config;

================
File: client/app/tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "types": ["node", "jest", "@babel/core", "@babel/generator", "@babel/template", "@babel/traverse", "json-schema"]
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}

================
File: docker-compose.yml
================
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: newcloud
      POSTGRES_USER: newcloud_user
      POSTGRES_PASSWORD: foxxdev1dt431
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - 5432:5432
    healthcheck:
      # trunk-ignore(yamllint/quoted-strings)
      test: ["CMD-SHELL", "pg_isready -U newcloud_user -d newcloud"]
      interval: 5s
      timeout: 5s
      retries: 5

  auth:
    build: 
      context: .
      dockerfile: services/auth/Dockerfile
    ports:
      - 3001:3001
    environment:
      - NODE_ENV=production
      - DB_USER=newcloud_user
      - DB_HOST=postgres
      - DB_NAME=newcloud
      - DB_PASSWORD=foxxdev1dt431
      - DB_PORT=5432
      - JWT_SECRET=test@69lol
      - FRONTEND_URL=http://localhost:3000
    depends_on:
      postgres:
        condition: service_healthy
    volumes:
      - ./services/auth/uploads:/usr/src/app/uploads

  client:
    build:
      context: ./client/app
      dockerfile: Dockerfile
    ports:
      - 3000:3000
    environment:
      - NODE_ENV=production
      - NEXT_PUBLIC_API_URL=http://localhost:3001
    depends_on:
      - auth

volumes:
  postgres_data:
  uploads_data:

================
File: Dockerfile
================
FROM node:20

WORKDIR /usr/src/app

# Copy package.json and package-lock.json
COPY client/app/package*.json ./

# Install dependencies
RUN npm install

# Copy the rest of the client code
COPY client/app .

# Build the Next.js app
RUN npm run build

# Expose the port the app runs on
EXPOSE 3000

# Command to run the application
CMD [ "npm", "start" ]

================
File: init.sql
================
CREATE TABLE IF NOT EXISTS roles (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    timezone VARCHAR(50) DEFAULT 'America/Boise',
    profile_picture_url VARCHAR(255),
    role_id INTEGER REFERENCES roles(id)
);

-- Insert default roles
INSERT INTO roles (name) VALUES ('user'), ('application_admin'), ('site_admin')
ON CONFLICT (name) DO NOTHING;

-- Grant necessary permissions
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO newcloud_user;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO newcloud_user;
GRANT ALL PRIVILEGES ON SCHEMA newcloud_schema TO newcloud_user;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA newcloud_schema TO newcloud_user;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA newcloud_schema TO newcloud_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA newcloud_schema GRANT ALL ON TABLES TO newcloud_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA newcloud_schema GRANT ALL ON SEQUENCES TO newcloud_user;

================
File: next-config-issue.txt
================
Parsing error: Cannot find module 'next/babel'
Require stack:
- C:\Users\IEMS-InfoSystemSecM\Documents\Projects\Nextcloud Alt - 1\New-Cloud\v1\new-cloud\client\app\node_modules\@babel\core\lib\config\files\plugins.js
- C:\Users\IEMS-InfoSystemSecM\Documents\Projects\Nextcloud Alt - 1\New-Cloud\v1\new-cloud\client\app\node_modules\@babel\core\lib\config\files\index.js
- C:\Users\IEMS-InfoSystemSecM\Documents\Projects\Nextcloud Alt - 1\New-Cloud\v1\new-cloud\client\app\node_modules\@babel\core\lib\index.js
- C:\Users\IEMS-InfoSystemSecM\Documents\Projects\Nextcloud Alt - 1\New-Cloud\v1\new-cloud\client\app\node_modules\@babel\eslint-parser\lib\worker\babel-core.cjs
- C:\Users\IEMS-InfoSystemSecM\Documents\Projects\Nextcloud Alt - 1\New-Cloud\v1\new-cloud\client\app\node_modules\@babel\eslint-parser\lib\worker\handle-message.cjs
- C:\Users\IEMS-InfoSystemSecM\Documents\Projects\Nextcloud Alt - 1\New-Cloud\v1\new-cloud\client\app\node_modules\@babel\eslint-parser\lib\client.cjs
- C:\Users\IEMS-InfoSystemSecM\Documents\Projects\Nextcloud Alt - 1\New-Cloud\v1\new-cloud\client\app\node_modules\@babel\eslint-parser\lib\index.cjs
- C:\Users\IEMS-InfoSystemSecM\Documents\Projects\Nextcloud Alt - 1\New-Cloud\v1\new-cloud\client\app\node_modules\@eslint\eslintrc\dist\eslintrc.cjs

Make sure that all the Babel plugins and presets you are using
are defined as dependencies or devDependencies in your package.json
file. It's possible that the missing plugin is loaded by a preset
you are using that forgot to add the plugin to its dependencies: you
can workaround this problem by explicitly adding the missing package
to your top-level package.json.eslint

================
File: notes.txt
================
-- Replace 'your_user' with the actual username from your .env file
GRANT ALL PRIVILEGES ON SCHEMA newcloud_schema TO newcloud_user;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA newcloud_schema TO newcloud_user;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA newcloud_schema TO newcloud_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA newcloud_schema GRANT ALL ON TABLES TO newcloud_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA newcloud_schema GRANT ALL ON SEQUENCES TO newcloud_user;

ALTER TABLE users OWNER TO newcloud_user;

ALTER USER newcloud_user WITH PASSWORD 'foxxdev1dt431';

================
File: package.json
================
{
  "name": "new-cloud-client",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "jest",
    "test:watch": "jest --watch"
  },
  "engines": {
    "node": "20.17.0"
  },
  "dependencies": {
    "@heroicons/react": "^2.1.5",
    "@tanstack/react-query": "^4.29.5",
    "axios": "^1.7.7",
    "babel": "^7.25.0",
    "new-cloud-client": "file:",
    "next": "^14.2.8",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@babel/eslint-parser": "^7.22.5",
    "@babel/preset-env": "^7.22.5",
    "@babel/preset-react": "^7.22.5",
    "@babel/preset-typescript": "^7.22.5",
    "@testing-library/jest-dom": "^6.5.0",
    "@testing-library/react": "^14.0.0",
    "@types/babel__core": "^7.20.5",
    "@types/babel__generator": "^7.6.8",
    "@types/babel__template": "^7.4.4",
    "@types/babel__traverse": "^7.20.6",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/json-schema": "^7.0.15",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/node": "^22.5.4",
    "@types/react": "^18.2.6",
    "@types/react-dom": "^18.2.4",
    "autoprefixer": "^10.4.14",
    "babel": "^6.23.0",
    "eslint": "^8.40.0",
    "eslint-config-next": "^14.2.8",
    "jest": "^29.5.0",
    "postcss": "^8.4.23",
    "tailwindcss": "^3.3.2",
    "typescript": "^5.6.2"
  }
}

================
File: README.md
================
# New Cloud

New Cloud is a modern web application built with Node.js, Next.js, and a microservices architecture. It aims to provide a robust cloud storage and collaboration platform.

## Project Structure

```
new-cloud/
 services/
    auth/
    files/ (planned)
    talk/ (planned)
    groupware/ (planned)
    office/ (planned)
 client/
    app/
 shared/ (planned)
    utils/
    models/
 gateway/ (planned)
 config/
 docker-compose.yml
 README.md
```

## Current State

The project is in active development. Currently, the following components are implemented:

- Authentication service
- Client application (Next.js)

## Technologies Used

### Backend
- Node.js (v20.x LTS)
- Express.js
- PostgreSQL
- JSON Web Tokens (JWT) for authentication
- bcrypt for password hashing
- multer for file uploads

### Frontend
- Next.js 14
- React 18
- TailwindCSS for styling
- Axios for API requests

### DevOps
- Docker and Docker Compose for containerization
- npm for package management

## Key Packages

### Backend (Auth Service)
- express: ^5.0.0
- jsonwebtoken: ^9.0.2
- bcrypt: ^5.1.1
- pg: ^8.12.0 (PostgreSQL client)
- multer: ^1.4.5-lts.1
- cors: ^2.8.5

### Frontend (Next.js App)
- next: ^14.2.8
- react: ^18.2.0
- react-dom: ^18.2.0
- @tanstack/react-query: ^5.55.4
- axios: ^1.7.7
- tailwindcss: ^3.3.2

## Setup Instructions

1. Clone the repository:
   ```
   git clone https://github.com/your-username/new-cloud.git
   cd new-cloud
   ```

2. Install dependencies:
   ```
   npm install
   cd client/app && npm install
   cd ../../services/auth && npm install
   ```

3. Set up environment variables:
   - Create a `.env` file in the root directory and in `services/auth/`
   - Add necessary environment variables (database connection, JWT secret, etc.)

4. Start the development servers:
   ```
   # In the root directory
   docker-compose up -d   # Start PostgreSQL

   # In services/auth
   npm run dev

   # In client/app
   npm run dev
   ```

5. Access the application:
   - Frontend: http://localhost:3000
   - Auth API: http://localhost:3001

## API Documentation

(Include a brief overview of available API endpoints, or link to a more detailed API documentation)

## Contributing

(Add guidelines for contributing to the project)

## License

(Specify the license under which the project is released)

## Roadmap

(To be added by you)

---

This README is a living document and will be updated as the project evolves.

================
File: services/auth/_tests_/auth.test.js
================
// services/auth/__tests__/auth.test.js
const request = require('supertest');
const app = require('../src/server'); // Assuming your Express app is exported from server.js

describe('Auth Service', () => {
  test('POST /register should create a new user', async () => {
    const res = await request(app)
      .post('/register')
      .send({
        username: 'testuser',
        password: 'testpassword'
      });
    expect(res.statusCode).toBe(201);
    expect(res.body).toHaveProperty('message', 'User created successfully');
  });

  test('POST /login should authenticate a user', async () => {
    const res = await request(app)
      .post('/login')
      .send({
        username: 'testuser',
        password: 'testpassword'
      });
    expect(res.statusCode).toBe(200);
    expect(res.body).toHaveProperty('token');
  });
});

================
File: services/auth/check-permissions.js
================
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: parseInt(process.env.DB_PORT || '5432'),
});

async function checkPermissions() {
  const client = await pool.connect();
  try {
    // Set search_path
    await client.query('SET search_path TO newcloud_schema, public');

    // Check table ownership
    const ownershipQuery = `
      SELECT tableowner 
      FROM pg_tables 
      WHERE schemaname = 'newcloud_schema' AND tablename = 'users'
    `;
    const ownershipResult = await client.query(ownershipQuery);
    console.log('Table owner:', ownershipResult.rows[0]?.tableowner);

    // Check user permissions
    const permissionsQuery = `
      SELECT grantee, privilege_type 
      FROM information_schema.role_table_grants 
      WHERE table_schema = 'newcloud_schema' 
      AND table_name = 'users' 
      AND grantee = $1
    `;
    const permissionsResult = await client.query(permissionsQuery, [process.env.DB_USER]);
    console.log('User permissions:', permissionsResult.rows);

    // Check if user is a superuser
    const superuserQuery = `
      SELECT rolsuper 
      FROM pg_roles 
      WHERE rolname = $1
    `;
    const superuserResult = await client.query(superuserQuery, [process.env.DB_USER]);
    console.log('Is superuser:', superuserResult.rows[0]?.rolsuper);

  } catch (err) {
    console.error('Error checking permissions:', err);
  } finally {
    client.release();
    await pool.end();
  }
}

checkPermissions();

================
File: services/auth/database.json
================
{
    "dev": {
      "driver": "pg",
      "user": "newcloud_user",
      "password": "foxxdev1dt431",
      "host": "localhost",
      "database": "newcloud",
      "port": "5432"
    }
  }

================
File: services/auth/db.ts
================
import { Pool, PoolConfig } from 'pg';
import dotenv from 'dotenv';

dotenv.config();

const poolConfig: PoolConfig = {
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD ? String(process.env.DB_PASSWORD) : undefined,
  port: parseInt(process.env.DB_PORT || '5432'),
  options: '-c search_path=newcloud_schema,public'
};

const pool = new Pool(poolConfig);

pool.on('error', (err) => {
  console.error('Unexpected error on idle client', err);
});

// Test database connection
pool.query('SELECT NOW()', (err, res) => {
  if (err) {
    console.error('Error connecting to the database:', err);
  } else {
    console.log('Successfully connected to the database');
  }
});

export default pool;

================
File: services/auth/dist/auth.js
================
"use strict";
// services/auth/src/auth.ts
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.authMiddleware = exports.generateToken = void 0;
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const JWT_SECRET = process.env.JWT_SECRET || 'test@69lol';
function generateToken(user) {
    return jsonwebtoken_1.default.sign({ id: user.id, username: user.username }, JWT_SECRET, { expiresIn: '1d' });
}
exports.generateToken = generateToken;
function authMiddleware(req, res, next) {
    const authHeader = req.headers.authorization;
    if (!authHeader) {
        return res.status(401).json({ message: 'No token provided' });
    }
    const token = authHeader.split(' ')[1];
    if (!token) {
        return res.status(401).json({ message: 'No token provided' });
    }
    try {
        const decoded = jsonwebtoken_1.default.verify(token, JWT_SECRET);
        req.user = decoded;
        next();
    }
    catch (error) {
        return res.status(401).json({ message: 'Invalid token' });
    }
}
exports.authMiddleware = authMiddleware;

================
File: services/auth/dist/db.js
================
"use strict";
// services/auth/src/db.ts
Object.defineProperty(exports, "__esModule", { value: true });
const pg_1 = require("pg");
const pool = new pg_1.Pool({
    user: process.env.DB_USER || 'newcloud_user',
    host: process.env.DB_HOST || 'localhost',
    database: process.env.DB_NAME || 'newcloud',
    password: process.env.DB_PASSWORD || 'NOTthisday@@22',
    port: parseInt(process.env.DB_PORT || '5432'),
});
exports.default = pool;

================
File: services/auth/dist/routes/auth.js
================
"use strict";
// services/auth/src/routes/auth.ts
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const bcrypt_1 = __importDefault(require("bcrypt"));
const auth_1 = require("../auth");
const server_1 = __importDefault(require("../server"));
const multer_1 = __importDefault(require("multer"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const router = express_1.default.Router();
const storage = multer_1.default.diskStorage({
    destination: function (req, file, cb) {
        cb(null, path_1.default.join(__dirname, '..', 'uploads'));
    },
    filename: function (req, file, cb) {
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
        cb(null, file.fieldname + '-' + uniqueSuffix + path_1.default.extname(file.originalname));
    }
});
const upload = (0, multer_1.default)({ storage: storage });
const uploadDir = path_1.default.join(__dirname, '..', 'uploads');
console.log('Upload directory:', uploadDir);
app.use('/uploads', express_1.default.static(uploadDir));
if (!fs_1.default.existsSync(uploadDir)) {
    fs_1.default.mkdirSync(uploadDir, { recursive: true });
}
router.post('/upload-avatar', auth_1.authMiddleware, upload.single('avatar'), (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    if (!req.file) {
        return res.status(400).json({ message: 'No file uploaded' });
    }
    try {
        const userId = req.user.id;
        const profilePictureUrl = `/uploads/${req.file.filename}`;
        yield server_1.default.query('UPDATE newcloud_schema.users SET profile_picture_url = $1 WHERE id = $2', [profilePictureUrl, userId]);
        console.log('File uploaded:', req.file);
        console.log('Profile picture URL:', profilePictureUrl);
        res.json({ profilePictureUrl });
    }
    catch (error) {
        console.error('Avatar upload error:', error);
        res.status(500).json({ message: 'Server error during avatar upload' });
    }
}));
router.post('/register', (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    const { username, email, password, firstName, lastName, timezone } = req.body;
    if (!username || !password || !firstName || !lastName) {
        return res.status(400).json({ message: 'Username, password, first name, and last name are required' });
    }
    try {
        console.log('Received registration request:', { username, email, firstName, lastName, timezone, passwordLength: password ? password.length : 0 });
        // Check if user already exists
        const userCheck = yield server_1.default.query('SELECT * FROM newcloud_schema.users WHERE username = $1', [username]);
        if (userCheck.rows.length > 0) {
            return res.status(400).json({ message: 'Username already exists' });
        }
        // Check if email exists if provided
        if (email) {
            const emailCheck = yield server_1.default.query('SELECT * FROM newcloud_schema.users WHERE email = $1', [email]);
            if (emailCheck.rows.length > 0) {
                return res.status(400).json({ message: 'Email already in use' });
            }
        }
        // Hash password
        const salt = yield bcrypt_1.default.genSalt(10);
        const hashedPassword = yield bcrypt_1.default.hash(String(password), salt);
        // Get the 'user' role id
        const roleResult = yield server_1.default.query('SELECT id FROM newcloud_schema.roles WHERE name = $1', ['user']);
        if (roleResult.rows.length === 0) {
            return res.status(500).json({ message: 'Default role not found' });
        }
        const roleId = roleResult.rows[0].id;
        // Insert new user with the 'user' role
        const newUser = yield server_1.default.query('INSERT INTO newcloud_schema.users (username, email, password, first_name, last_name, timezone, role_id) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, username', [username, email || null, hashedPassword, firstName, lastName, timezone || 'America/Boise', roleId]);
        const token = (0, auth_1.generateToken)({ id: newUser.rows[0].id, username: newUser.rows[0].username });
        res.status(201).json({ token });
    }
    catch (error) {
        console.error('Registration error:', error);
        if (error instanceof Error) {
            res.status(500).json({ message: 'Server error during registration', error: error.message });
        }
        else {
            res.status(500).json({ message: 'Server error during registration' });
        }
    }
}));
router.post('/login', (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    const { username, password } = req.body;
    try {
        const user = yield server_1.default.query('SELECT * FROM newcloud_schema.users WHERE username = $1', [username]);
        if (user.rows.length === 0) {
            return res.status(400).json({ message: 'Invalid credentials' });
        }
        const validPassword = yield bcrypt_1.default.compare(password, user.rows[0].password);
        if (!validPassword) {
            return res.status(400).json({ message: 'Invalid credentials' });
        }
        const token = (0, auth_1.generateToken)({ id: user.rows[0].id, username: user.rows[0].username });
        res.json({ token });
    }
    catch (error) {
        console.error('Login error:', error);
        if (error instanceof Error) {
            res.status(500).json({ message: 'Server error during login', error: error.message });
        }
        else {
            res.status(500).json({ message: 'Server error during login' });
        }
    }
}));
router.get('/profile', auth_1.authMiddleware, (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const userId = req.user.id;
        const result = yield server_1.default.query('SELECT u.id, u.username, u.email, r.name as role FROM users u JOIN roles r ON u.role_id = r.id WHERE u.id = $1', [userId]);
        if (result.rows.length === 0) {
            return res.status(404).json({ message: 'User not found' });
        }
        console.log('Profile data:', result.rows[0]); // Add this line
        res.json(result.rows[0]);
    }
    catch (error) {
        console.error('Profile fetch error:', error);
        res.status(500).json({ message: 'Server error' });
    }
}));
router.put('/profile', auth_1.authMiddleware, (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const userId = req.user.id;
        const { username, email } = req.body;
        // Check if username already exists
        if (username) {
            const usernameCheck = yield server_1.default.query('SELECT id FROM users WHERE username = $1 AND id != $2', [username, userId]);
            if (usernameCheck.rows.length > 0) {
                return res.status(400).json({ message: 'Username already taken' });
            }
        }
        // Update user profile
        const result = yield server_1.default.query('UPDATE users SET username = COALESCE($1, username), email = COALESCE($2, email) WHERE id = $3 RETURNING id, username, email', [username, email, userId]);
        if (result.rows.length === 0) {
            return res.status(404).json({ message: 'User not found' });
        }
        res.json(result.rows[0]);
    }
    catch (error) {
        console.error('Profile update error:', error);
        res.status(500).json({ message: 'Server error' });
    }
}));
router.put('/change-password', auth_1.authMiddleware, (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const userId = req.user.id;
        const { currentPassword, newPassword } = req.body;
        // Fetch the user from the database
        const userResult = yield server_1.default.query('SELECT * FROM users WHERE id = $1', [userId]);
        if (userResult.rows.length === 0) {
            return res.status(404).json({ message: 'User not found' });
        }
        const user = userResult.rows[0];
        // Verify current password
        const isValidPassword = yield bcrypt_1.default.compare(currentPassword, user.password);
        if (!isValidPassword) {
            return res.status(400).json({ message: 'Current password is incorrect' });
        }
        // Hash the new password
        const salt = yield bcrypt_1.default.genSalt(10);
        const hashedNewPassword = yield bcrypt_1.default.hash(newPassword, salt);
        // Update the password in the database
        yield server_1.default.query('UPDATE users SET password = $1 WHERE id = $2', [hashedNewPassword, userId]);
        res.json({ message: 'Password updated successfully' });
    }
    catch (error) {
        console.error('Password change error:', error);
        res.status(500).json({ message: 'Server error' });
    }
}));
router.post('/upload-avatar', auth_1.authMiddleware, upload.single('avatar'), (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    if (!req.file) {
        return res.status(400).json({ message: 'No file uploaded' });
    }
    try {
        const userId = req.user.id;
        const profilePictureUrl = `/uploads/${req.file.filename}`; // This should be a URL, not a file path
        yield server_1.default.query('UPDATE users SET profile_picture_url = $1 WHERE id = $2', [profilePictureUrl, userId]);
        res.json({ profilePictureUrl });
    }
    catch (error) {
        console.error('Avatar upload error:', error);
        res.status(500).json({ message: 'Server error during avatar upload' });
    }
}));
const isSiteAdmin = (req, res, next) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const userId = req.user.id;
    const result = yield server_1.default.query('SELECT r.name FROM users u JOIN roles r ON u.role_id = r.id WHERE u.id = $1', [userId]);
    if (((_a = result.rows[0]) === null || _a === void 0 ? void 0 : _a.name) === 'site_admin') {
        next();
    }
    else {
        res.status(403).json({ message: 'Access denied' });
    }
});
// Middleware to check if user is an application admin or site admin
const isAdmin = (req, res, next) => __awaiter(void 0, void 0, void 0, function* () {
    var _b;
    const userId = req.user.id;
    const result = yield server_1.default.query('SELECT r.name FROM users u JOIN roles r ON u.role_id = r.id WHERE u.id = $1', [userId]);
    if (['site_admin', 'application_admin'].includes((_b = result.rows[0]) === null || _b === void 0 ? void 0 : _b.name)) {
        next();
    }
    else {
        res.status(403).json({ message: 'Access denied' });
    }
});
// Route to get all users (admin only)
router.get('/users', auth_1.authMiddleware, isAdmin, (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const result = yield server_1.default.query('SELECT u.id, u.username, u.email, r.name as role FROM users u JOIN roles r ON u.role_id = r.id');
        res.json(result.rows);
    }
    catch (error) {
        console.error('Error fetching users:', error);
        res.status(500).json({ message: 'Server error' });
    }
}));
// Route to update user role (site admin only)
router.put('/users/:id/role', auth_1.authMiddleware, isSiteAdmin, (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    const { id } = req.params;
    const { role } = req.body;
    try {
        const roleResult = yield server_1.default.query('SELECT id FROM roles WHERE name = $1', [role]);
        if (roleResult.rows.length === 0) {
            return res.status(400).json({ message: 'Invalid role' });
        }
        const roleId = roleResult.rows[0].id;
        yield server_1.default.query('UPDATE users SET role_id = $1 WHERE id = $2', [roleId, id]);
        res.json({ message: 'User role updated successfully' });
    }
    catch (error) {
        console.error('Error updating user role:', error);
        res.status(500).json({ message: 'Server error' });
    }
}));
router.put('/users/:id/role', auth_1.authMiddleware, isSiteAdmin, (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    const { id } = req.params;
    const { role } = req.body;
    try {
        // Check if the role is valid
        const validRoles = ['user', 'application_admin', 'site_admin'];
        if (!validRoles.includes(role)) {
            return res.status(400).json({ message: 'Invalid role' });
        }
        const roleResult = yield server_1.default.query('SELECT id FROM roles WHERE name = $1', [role]);
        if (roleResult.rows.length === 0) {
            return res.status(400).json({ message: 'Invalid role' });
        }
        const roleId = roleResult.rows[0].id;
        yield server_1.default.query('UPDATE users SET role_id = $1 WHERE id = $2', [roleId, id]);
        res.json({ message: 'User role updated successfully' });
    }
    catch (error) {
        console.error('Error updating user role:', error);
        res.status(500).json({ message: 'Server error' });
    }
}));
router.post('/upload-avatar', auth_1.authMiddleware, upload.single('avatar'), (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    if (!req.file) {
        return res.status(400).json({ message: 'No file uploaded' });
    }
    try {
        const userId = req.user.id;
        const profilePictureUrl = `/uploads/${req.file.filename}`;
        yield server_1.default.query('UPDATE users SET profile_picture_url = $1 WHERE id = $2', [profilePictureUrl, userId]);
        res.json({ profilePictureUrl });
    }
    catch (error) {
        console.error('Avatar upload error:', error);
        res.status(500).json({ message: 'Server error during avatar upload' });
    }
}));
// Update the existing /profile PUT route
router.put('/profile', auth_1.authMiddleware, (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const userId = req.user.id;
        const { firstName, lastName, email, timezone } = req.body;
        const result = yield server_1.default.query('UPDATE users SET first_name = $1, last_name = $2, email = $3, timezone = $4 WHERE id = $5 RETURNING id, username, email, first_name, last_name, timezone, profile_picture_url', [firstName, lastName, email, timezone, userId]);
        if (result.rows.length === 0) {
            return res.status(404).json({ message: 'User not found' });
        }
        res.json(result.rows[0]);
    }
    catch (error) {
        console.error('Profile update error:', error);
        res.status(500).json({ message: 'Server error during profile update' });
    }
}));
router.post('/upload-avatar', auth_1.authMiddleware, upload.single('avatar'), (req, res) => __awaiter(void 0, void 0, void 0, function* () {
    if (!req.file) {
        return res.status(400).json({ message: 'No file uploaded' });
    }
    try {
        const userId = req.user.id;
        const profilePictureUrl = `/uploads/${req.file.filename}`;
        yield server_1.default.query('UPDATE users SET profile_picture_url = $1 WHERE id = $2', [profilePictureUrl, userId]);
        res.json({ profilePictureUrl });
    }
    catch (error) {
        console.error('Avatar upload error:', error);
        res.status(500).json({ message: 'Server error during avatar upload' });
    }
}));
exports.default = router;

================
File: services/auth/dist/server.js
================
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const cors_1 = __importDefault(require("cors"));
const auth_1 = __importDefault(require("./routes/auth"));
const path_1 = __importDefault(require("path"));
const pg_1 = require("pg");
const dotenv_1 = __importDefault(require("dotenv"));
dotenv_1.default.config({ path: path_1.default.resolve(__dirname, '../../../.env') });
const app = (0, express_1.default)();
const PORT = process.env.PORT || 3001;
app.use((0, cors_1.default)({
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    methods: ['GET', 'POST', 'PUT', 'DELETE'],
    allowedHeaders: ['Content-Type', 'Authorization'],
}));
app.use(express_1.default.json());
app.use('/auth', auth_1.default);
const server = app.listen(PORT, () => {
    console.log(`Auth service running on port ${PORT}`);
});
const pool = new pg_1.Pool({
    user: process.env.DB_USER,
    host: process.env.DB_HOST,
    database: process.env.DB_NAME,
    password: process.env.DB_PASSWORD ? String(process.env.DB_PASSWORD) : undefined,
    port: parseInt(process.env.DB_PORT || '5432'),
    options: '-c search_path=newcloud_schema,public'
});
const uploadDir = path_1.default.join(__dirname, '..', 'uploads');
app.use('/uploads', express_1.default.static(uploadDir));
// Use auth routes
app.use('/auth', auth_1.default);
pool.on('error', (err) => {
    console.error('Unexpected error on idle client', err);
});
// Test database connection
pool.query('SELECT NOW()', (err, res) => {
    if (err) {
        console.error('Error connecting to the database:', err);
    }
    else {
        console.log('Successfully connected to the database');
    }
});
console.log('Database connection details:');
console.log('DB_USER:', process.env.DB_USER);
console.log('DB_HOST:', process.env.DB_HOST);
console.log('DB_NAME:', process.env.DB_NAME);
console.log('DB_PASSWORD is set:', !!process.env.DB_PASSWORD);
console.log('DB_PORT:', process.env.DB_PORT);
exports.default = pool;

================
File: services/auth/Dockerfile
================
FROM node:22

WORKDIR /usr/src/app

# Copy package.json and package-lock.json from the parent directory
COPY services/auth/package*.json ./

# Install dependencies
RUN npm install

# Copy the rest of the auth service code
COPY services/auth .

# Typescript is a devDependency, so we need to install it for the build
RUN npm install typescript@latest

# Build the app
RUN npm run build

EXPOSE 3001

# Run the compiled JavaScript
CMD ["node", "dist/server.js"]

RUN mkdir -p /usr/src/app/uploads && chmod 775 /usr/src/app/uploads

================
File: services/auth/manual-migration.js
================
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: parseInt(process.env.DB_PORT || '5432'),
});

async function addProfilePictureColumn() {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    // Set search_path
    await client.query('SET search_path TO newcloud_schema, public');

    // Check if the column already exists
    const checkColumnQuery = `
      SELECT column_name 
      FROM information_schema.columns 
      WHERE table_schema = 'newcloud_schema' 
      AND table_name = 'users' 
      AND column_name = 'profile_picture_url'
    `;
    const checkResult = await client.query(checkColumnQuery);

    if (checkResult.rows.length === 0) {
      // Add the column if it doesn't exist
      await client.query(`
        ALTER TABLE users 
        ADD COLUMN profile_picture_url VARCHAR(255)
      `);
      console.log('Added profile_picture_url column');

      // Set default value for existing rows
      await client.query(`
        UPDATE users 
        SET profile_picture_url = '/default-avatar.png' 
        WHERE profile_picture_url IS NULL
      `);
      console.log('Set default value for profile_picture_url');
    } else {
      console.log('profile_picture_url column already exists');
    }

    await client.query('COMMIT');
    console.log('Migration completed successfully');
  } catch (err) {
    await client.query('ROLLBACK');
    console.error('Error during migration:', err);
  } finally {
    client.release();
    await pool.end();
  }
}

addProfilePictureColumn();

================
File: services/auth/migrations/20240311120000_add_profile_picture_url.sql
================
-- In each migration file (e.g., 20240311120000_add_profile_picture_url.sql)
SET search_path TO newcloud_schema, public;

-- Your existing migration SQL follows...
ALTER TABLE users
ADD COLUMN profile_picture_url VARCHAR(255);

UPDATE users SET profile_picture_url = '/default-avatar.png' WHERE profile_picture_url IS NULL;

================
File: services/auth/package.json
================
{
  "name": "new-cloud-client",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "jest",
    "test:watch": "jest --watch"
  },
  "engines": {
    "node": "20.17.0"
  },
  "dependencies": {
    "@heroicons/react": "^2.1.5",
    "@tanstack/react-query": "^4.29.5",
    "axios": "^1.7.7",
    "babel": "^7.25.0",
    "new-cloud-client": "file:",
    "next": "^14.2.8",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@babel/eslint-parser": "^7.22.5",
    "@babel/preset-env": "^7.22.5",
    "@babel/preset-react": "^7.22.5",
    "@babel/preset-typescript": "^7.22.5",
    "@testing-library/jest-dom": "^6.5.0",
    "@testing-library/react": "^14.0.0",
    "@types/babel__core": "^7.20.5",
    "@types/babel__generator": "^7.6.8",
    "@types/babel__template": "^7.4.4",
    "@types/babel__traverse": "^7.20.6",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/json-schema": "^7.0.15",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/node": "^22.5.4",
    "@types/react": "^18.2.6",
    "@types/react-dom": "^18.2.4",
    "autoprefixer": "^10.4.14",
    "babel": "^6.23.0",
    "eslint": "^8.40.0",
    "eslint-config-next": "^14.2.8",
    "jest": "^29.5.0",
    "postcss": "^8.4.23",
    "tailwindcss": "^3.3.2",
    "typescript": "^5.6.2"
  }
}

================
File: services/auth/repopack-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-09-11T20:18:08.709Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
_tests_/auth.test.js
check-permissions.js
database.json
db.js
db.ts
Dockerfile.test
manual-migration.js
migrations/20240311120000_add_profile_picture_url.sql
package.json
run-migration.js
server.js
src/auth.ts
src/Dockerfile
src/routes/auth.ts
src/server.ts
test-db-connection.js
tsconfig.json

================================================================
Repository Files
================================================================

================
File: _tests_/auth.test.js
================
// services/auth/__tests__/auth.test.js
const request = require('supertest');
const app = require('../src/server'); // Assuming your Express app is exported from server.js

describe('Auth Service', () => {
  test('POST /register should create a new user', async () => {
    const res = await request(app)
      .post('/register')
      .send({
        username: 'testuser',
        password: 'testpassword'
      });
    expect(res.statusCode).toBe(201);
    expect(res.body).toHaveProperty('message', 'User created successfully');
  });

  test('POST /login should authenticate a user', async () => {
    const res = await request(app)
      .post('/login')
      .send({
        username: 'testuser',
        password: 'testpassword'
      });
    expect(res.statusCode).toBe(200);
    expect(res.body).toHaveProperty('token');
  });
});

================
File: check-permissions.js
================
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: parseInt(process.env.DB_PORT || '5432'),
});

async function checkPermissions() {
  const client = await pool.connect();
  try {
    // Set search_path
    await client.query('SET search_path TO newcloud_schema, public');

    // Check table ownership
    const ownershipQuery = `
      SELECT tableowner 
      FROM pg_tables 
      WHERE schemaname = 'newcloud_schema' AND tablename = 'users'
    `;
    const ownershipResult = await client.query(ownershipQuery);
    console.log('Table owner:', ownershipResult.rows[0]?.tableowner);

    // Check user permissions
    const permissionsQuery = `
      SELECT grantee, privilege_type 
      FROM information_schema.role_table_grants 
      WHERE table_schema = 'newcloud_schema' 
      AND table_name = 'users' 
      AND grantee = $1
    `;
    const permissionsResult = await client.query(permissionsQuery, [process.env.DB_USER]);
    console.log('User permissions:', permissionsResult.rows);

    // Check if user is a superuser
    const superuserQuery = `
      SELECT rolsuper 
      FROM pg_roles 
      WHERE rolname = $1
    `;
    const superuserResult = await client.query(superuserQuery, [process.env.DB_USER]);
    console.log('Is superuser:', superuserResult.rows[0]?.rolsuper);

  } catch (err) {
    console.error('Error checking permissions:', err);
  } finally {
    client.release();
    await pool.end();
  }
}

checkPermissions();

================
File: database.json
================
{
    "dev": {
      "driver": "pg",
      "user": "newcloud_user",
      "password": "NOTthisday@@22",
      "host": "localhost",
      "database": "newcloud",
      "port": "5432"
    }
  }

================
File: db.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pg_1 = require("pg");
const poolConfig = {
    user: process.env.DB_USER,
    host: process.env.DB_HOST,
    database: process.env.DB_NAME,
    password: process.env.DB_PASSWORD,
    port: parseInt(process.env.DB_PORT || '5432'),
    options: '-c search_path=newcloud_schema,public'
};
const pool = new pg_1.Pool(poolConfig);
exports.default = pool;

================
File: db.ts
================
import { Pool, PoolConfig } from 'pg';

const poolConfig: PoolConfig = {
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: parseInt(process.env.DB_PORT || '5432'),
  options: '-c search_path=newcloud_schema,public'
};

const pool = new Pool(poolConfig);

export default pool;

================
File: Dockerfile.test
================
FROM node:20

WORKDIR /usr/src/app

COPY package*.json ./
RUN npm install

COPY . .
RUN npm run build

EXPOSE 3001
CMD ["npm", "start"]

================
File: manual-migration.js
================
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: parseInt(process.env.DB_PORT || '5432'),
});

async function addProfilePictureColumn() {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    // Set search_path
    await client.query('SET search_path TO newcloud_schema, public');

    // Check if the column already exists
    const checkColumnQuery = `
      SELECT column_name 
      FROM information_schema.columns 
      WHERE table_schema = 'newcloud_schema' 
      AND table_name = 'users' 
      AND column_name = 'profile_picture_url'
    `;
    const checkResult = await client.query(checkColumnQuery);

    if (checkResult.rows.length === 0) {
      // Add the column if it doesn't exist
      await client.query(`
        ALTER TABLE users 
        ADD COLUMN profile_picture_url VARCHAR(255)
      `);
      console.log('Added profile_picture_url column');

      // Set default value for existing rows
      await client.query(`
        UPDATE users 
        SET profile_picture_url = '/default-avatar.png' 
        WHERE profile_picture_url IS NULL
      `);
      console.log('Set default value for profile_picture_url');
    } else {
      console.log('profile_picture_url column already exists');
    }

    await client.query('COMMIT');
    console.log('Migration completed successfully');
  } catch (err) {
    await client.query('ROLLBACK');
    console.error('Error during migration:', err);
  } finally {
    client.release();
    await pool.end();
  }
}

addProfilePictureColumn();

================
File: migrations/20240311120000_add_profile_picture_url.sql
================
-- In each migration file (e.g., 20240311120000_add_profile_picture_url.sql)
SET search_path TO newcloud_schema, public;

-- Your existing migration SQL follows...
ALTER TABLE users
ADD COLUMN profile_picture_url VARCHAR(255);

UPDATE users SET profile_picture_url = '/default-avatar.png' WHERE profile_picture_url IS NULL;

================
File: package.json
================
{
  "name": "auth-service",
  "version": "1.0.0",
  "main": "dist/server.js",
  "scripts": {
    "start": "node dist/server.js",
    "dev": "nodemon src/server.ts",
    "build": "tsc",
    "watch": "tsc -w",
    "migrate": "node -r dotenv/config ./node_modules/.bin/node-pg-migrate",
    "migrate:up": "node-pg-migrate up",
    "migrate:down": "node-pg-migrate down"
  },
  "dependencies": {
    "auth-service": "file:",
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "express": "^5.0.0",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.1",
    "node-pg-migrate": "^7.6.1"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/cors": "^2.8.12",
    "@types/express": "^4.17.13",
    "@types/jsonwebtoken": "^8.5.5",
    "@types/multer": "^1.4.12",
    "@types/node": "^16.11.6",
    "@types/pg": "^8.11.8",
    "dotenv": "^16.4.5",
    "node-pg-migrate": "^7.6.1",
    "nodemon": "^3.1.0",
    "pg": "^8.12.0",
    "ts-node": "^10.4.0",
    "typescript": "^4.4.4"
  }
}

================
File: run-migration.js
================
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: parseInt(process.env.DB_PORT || '5432'),
});

async function verifyAndCreateSchema() {
  const client = await pool.connect();
  try {
    console.log('Successfully connected to the database');

    // Check search_path
    const searchPathResult = await client.query('SHOW search_path');
    console.log('Current search_path:', searchPathResult.rows[0].search_path);

    // List all schemas
    const allSchemasResult = await client.query(`
      SELECT schema_name 
      FROM information_schema.schemata 
      WHERE schema_name NOT LIKE 'pg_%' AND schema_name != 'information_schema'
    `);
    console.log('Available schemas:', allSchemasResult.rows.map(row => row.schema_name));

    // Check if the schema exists
    const schemaResult = await client.query(`
      SELECT schema_name 
      FROM information_schema.schemata 
      WHERE schema_name = 'newcloud_schema'
    `);
    
    if (schemaResult.rows.length > 0) {
      console.log('newcloud_schema exists');
    } else {
      console.log('newcloud_schema does not exist, attempting to create...');
      await client.query('CREATE SCHEMA IF NOT EXISTS newcloud_schema');
      console.log('newcloud_schema created');
    }

    // Set search_path to include newcloud_schema
    await client.query('SET search_path TO newcloud_schema, public');
    console.log('Set search_path to include newcloud_schema');

    // Check user permissions
    const permissionsResult = await client.query(`
      SELECT has_schema_privilege('${process.env.DB_USER}', 'newcloud_schema', 'CREATE')
    `);
    console.log('User has CREATE permission on newcloud_schema:', permissionsResult.rows[0].has_schema_privilege);

  } catch (err) {
    console.error('Error:', err);
  } finally {
    client.release();
    await pool.end();
  }
}

verifyAndCreateSchema();

================
File: server.js
================
"use strict";
// services/auth/src/server.ts
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dotenv_1 = __importDefault(require("dotenv"));
dotenv_1.default.config();
const express_1 = __importDefault(require("express"));
const cors_1 = __importDefault(require("cors"));
const auth_1 = __importDefault(require("./src/routes/auth"));
const path_1 = __importDefault(require("path"));
const pg_1 = require("pg");
const app = (0, express_1.default)();
const PORT = process.env.PORT || 3001;
app.use((0, cors_1.default)({
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    methods: ['GET', 'POST', 'PUT', 'DELETE'],
    allowedHeaders: ['Content-Type', 'Authorization'],
}));
app.use(express_1.default.json());
app.use('/auth', auth_1.default);
app.listen(PORT, () => {
    console.log(`Auth service running on port ${PORT}`);
});
app.use('/uploads', express_1.default.static(path_1.default.join(__dirname, '..', 'uploads')));
const pool = new pg_1.Pool({
    user: process.env.DB_USER,
    host: process.env.DB_HOST,
    database: process.env.DB_NAME,
    password: String(process.env.DB_PASSWORD),
    port: parseInt(process.env.DB_PORT || '5432'),
});
exports.default = pool;

================
File: src/auth.ts
================
// services/auth/src/auth.ts

import jwt from 'jsonwebtoken';
import { Request, Response, NextFunction } from 'express';

const JWT_SECRET = process.env.JWT_SECRET || 'test@69lol';

interface User {
  id: string;
  username: string;
}

export function generateToken(user: { id: string; username: string }): string {
    return jwt.sign({ id: user.id, username: user.username }, JWT_SECRET, { expiresIn: '1d' });
  }
  
  export function authMiddleware(req: Request, res: Response, next: NextFunction) {
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      return res.status(401).json({ message: 'No token provided' });
    }
  
    const token = authHeader.split(' ')[1];
    if (!token) {
      return res.status(401).json({ message: 'No token provided' });
    }
  
    try {
      const decoded = jwt.verify(token, JWT_SECRET) as { id: string; username: string };
      (req as any).user = decoded;
      next();
    } catch (error) {
      return res.status(401).json({ message: 'Invalid token' });
    }
  }

================
File: src/Dockerfile
================
FROM node:20

WORKDIR /usr/src/app

# Copy package.json and package-lock.json from the parent directory
COPY services/auth/package*.json ./

# Install dependencies
RUN npm install

# Copy the rest of the auth service code
COPY services/auth .

# Typescript is a devDependency, so we need to install it for the build
RUN npm install typescript

# Build the app
RUN npm run build

EXPOSE 3001

# Run the compiled JavaScript
CMD ["node", "dist/server.js"]

RUN mkdir -p /usr/src/app/uploads && chmod 775 /usr/src/app/uploads

================
File: src/routes/auth.ts
================
// services/auth/src/routes/auth.ts

import express from 'express';
import bcrypt from 'bcrypt';
import { generateToken, authMiddleware } from '../auth';
import pool from '../server';
import multer from 'multer';
import path from 'path';
import fs from 'fs';

const router = express.Router();
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, path.join(__dirname, '..', 'uploads'));
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({ storage: storage });

const uploadDir = path.join(__dirname, '..', 'uploads');

if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}


router.post('/upload-avatar', authMiddleware, upload.single('avatar'), async (req, res) => {
  if (!req.file) {
    return res.status(400).json({ message: 'No file uploaded' });
  }

  try {
    const userId = (req as any).user.id;
    const profilePictureUrl = `/uploads/${req.file.filename}`;
    
    // Log the file details for debugging
    console.log('File uploaded:', req.file);
    console.log('Profile picture URL:', profilePictureUrl);
    // Update the user's profile picture URL in the database
    await pool.query('UPDATE users SET profile_picture_url = $1 WHERE id = $2', [profilePictureUrl, userId]);
    
    res.json({ profilePictureUrl });
  } catch (error) {
    console.error('Avatar upload error:', error);
    res.status(500).json({ message: 'Server error during avatar upload' });
  }
});

router.post('/register', async (req, res) => {
    const { username, email, password, firstName, lastName, timezone } = req.body;
  
    if (!username || !password || !firstName || !lastName) {
      return res.status(400).json({ message: 'Username, password, first name, and last name are required' });
    }
  
    try {
      // Check if user already exists
      const userCheck = await pool.query('SELECT * FROM newcloud_schema.users WHERE username = $1', [username]);
      if (userCheck.rows.length > 0) {
        return res.status(400).json({ message: 'Username already exists' });
      }
  
      // Check if email exists if provided
      if (email) {
        const emailCheck = await pool.query('SELECT * FROM newcloud_schema.users WHERE email = $1', [email]);
        if (emailCheck.rows.length > 0) {
          return res.status(400).json({ message: 'Email already in use' });
        }
      }
  
      // Hash password
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(password, salt);
  
      // Get the 'user' role id
      const roleResult = await pool.query('SELECT id FROM newcloud_schema.roles WHERE name = $1', ['user']);
      if (roleResult.rows.length === 0) {
        return res.status(500).json({ message: 'Default role not found' });
      }
      const roleId = roleResult.rows[0].id;
  
      // Insert new user with the 'user' role
      const newUser = await pool.query(
        'INSERT INTO newcloud_schema.users (username, email, password, first_name, last_name, timezone, role_id) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, username',
        [username, email || null, hashedPassword, firstName, lastName, timezone || 'America/Boise', roleId]
      );
  
      const token = generateToken({ id: newUser.rows[0].id, username: newUser.rows[0].username });
      res.status(201).json({ token });
    } catch (error) {
        console.error('Registration error:', error);
        if (error instanceof Error) {
          res.status(500).json({ message: 'Server error during registration', error: error.message });
        } else {
          res.status(500).json({ message: 'Server error during registration' });
        }
      }
  });
  
  router.post('/login', async (req, res) => {
    const { username, password } = req.body;
  
    try {
      const user = await pool.query('SELECT * FROM newcloud_schema.users WHERE username = $1', [username]);
  
      if (user.rows.length === 0) {
        return res.status(400).json({ message: 'Invalid credentials' });
      }
  
      const validPassword = await bcrypt.compare(password, user.rows[0].password);
      if (!validPassword) {
        return res.status(400).json({ message: 'Invalid credentials' });
      }
  
      const token = generateToken({ id: user.rows[0].id, username: user.rows[0].username });
      res.json({ token });
    } catch (error) {
        console.error('Login error:', error);
        if (error instanceof Error) {
          res.status(500).json({ message: 'Server error during login', error: error.message });
        } else {
          res.status(500).json({ message: 'Server error during login' });
        }
      }
  });


/* router.get('/profile', authMiddleware, async (req, res) => {
  try {
    const userId = (req as any).user.id;
    const result = await pool.query('SELECT id, username, email FROM users WHERE id = $1', [userId]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ message: 'User not found' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    console.error('Profile fetch error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});
*/

router.get('/profile', authMiddleware, async (req, res) => {
    try {
      const userId = (req as any).user.id;
      const result = await pool.query(
        'SELECT u.id, u.username, u.email, r.name as role FROM users u JOIN roles r ON u.role_id = r.id WHERE u.id = $1',
        [userId]
      );
      
      if (result.rows.length === 0) {
        return res.status(404).json({ message: 'User not found' });
      }
  
      console.log('Profile data:', result.rows[0]); // Add this line
  
      res.json(result.rows[0]);
    } catch (error) {
      console.error('Profile fetch error:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });

router.put('/profile', authMiddleware, async (req, res) => {
  try {
    const userId = (req as any).user.id;
    const { username, email } = req.body;

    // Check if username already exists
    if (username) {
      const usernameCheck = await pool.query('SELECT id FROM users WHERE username = $1 AND id != $2', [username, userId]);
      if (usernameCheck.rows.length > 0) {
        return res.status(400).json({ message: 'Username already taken' });
      }
    }

    // Update user profile
    const result = await pool.query(
      'UPDATE users SET username = COALESCE($1, username), email = COALESCE($2, email) WHERE id = $3 RETURNING id, username, email',
      [username, email, userId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ message: 'User not found' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    console.error('Profile update error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

router.put('/change-password', authMiddleware, async (req, res) => {
    try {
      const userId = (req as any).user.id;
      const { currentPassword, newPassword } = req.body;
  
      // Fetch the user from the database
      const userResult = await pool.query('SELECT * FROM users WHERE id = $1', [userId]);
      if (userResult.rows.length === 0) {
        return res.status(404).json({ message: 'User not found' });
      }
  
      const user = userResult.rows[0];
  
      // Verify current password
      const isValidPassword = await bcrypt.compare(currentPassword, user.password);
      if (!isValidPassword) {
        return res.status(400).json({ message: 'Current password is incorrect' });
      }
  
      // Hash the new password
      const salt = await bcrypt.genSalt(10);
      const hashedNewPassword = await bcrypt.hash(newPassword, salt);
  
      // Update the password in the database
      await pool.query('UPDATE users SET password = $1 WHERE id = $2', [hashedNewPassword, userId]);
  
      res.json({ message: 'Password updated successfully' });
    } catch (error) {
      console.error('Password change error:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });

  router.post('/upload-avatar', authMiddleware, upload.single('avatar'), async (req, res) => {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }
  
    try {
      const userId = (req as any).user.id;
      const profilePictureUrl = `/uploads/${req.file.filename}`; // This should be a URL, not a file path
      
      await pool.query('UPDATE users SET profile_picture_url = $1 WHERE id = $2', [profilePictureUrl, userId]);
      
      res.json({ profilePictureUrl });
    } catch (error) {
      console.error('Avatar upload error:', error);
      res.status(500).json({ message: 'Server error during avatar upload' });
    }
  });

  const isSiteAdmin = async (req: any, res: any, next: any) => {
    const userId = req.user.id;
    const result = await pool.query(
      'SELECT r.name FROM users u JOIN roles r ON u.role_id = r.id WHERE u.id = $1',
      [userId]
    );
    if (result.rows[0]?.name === 'site_admin') {
      next();
    } else {
      res.status(403).json({ message: 'Access denied' });
    }
  };
  
  // Middleware to check if user is an application admin or site admin
  const isAdmin = async (req: any, res: any, next: any) => {
    const userId = req.user.id;
    const result = await pool.query(
      'SELECT r.name FROM users u JOIN roles r ON u.role_id = r.id WHERE u.id = $1',
      [userId]
    );
    if (['site_admin', 'application_admin'].includes(result.rows[0]?.name)) {
      next();
    } else {
      res.status(403).json({ message: 'Access denied' });
    }
  };
  
  // Route to get all users (admin only)
  router.get('/users', authMiddleware, isAdmin, async (req, res) => {
    try {
      const result = await pool.query('SELECT u.id, u.username, u.email, r.name as role FROM users u JOIN roles r ON u.role_id = r.id');
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching users:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });
  
  // Route to update user role (site admin only)
  router.put('/users/:id/role', authMiddleware, isSiteAdmin, async (req, res) => {
    const { id } = req.params;
    const { role } = req.body;
  
    try {
      const roleResult = await pool.query('SELECT id FROM roles WHERE name = $1', [role]);
      if (roleResult.rows.length === 0) {
        return res.status(400).json({ message: 'Invalid role' });
      }
  
      const roleId = roleResult.rows[0].id;
      await pool.query('UPDATE users SET role_id = $1 WHERE id = $2', [roleId, id]);
      res.json({ message: 'User role updated successfully' });
    } catch (error) {
      console.error('Error updating user role:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });

  router.put('/users/:id/role', authMiddleware, isSiteAdmin, async (req, res) => {
    const { id } = req.params;
    const { role } = req.body;
  
    try {
      // Check if the role is valid
      const validRoles = ['user', 'application_admin', 'site_admin'];
      if (!validRoles.includes(role)) {
        return res.status(400).json({ message: 'Invalid role' });
      }
  
      const roleResult = await pool.query('SELECT id FROM roles WHERE name = $1', [role]);
      if (roleResult.rows.length === 0) {
        return res.status(400).json({ message: 'Invalid role' });
      }
  
      const roleId = roleResult.rows[0].id;
      await pool.query('UPDATE users SET role_id = $1 WHERE id = $2', [roleId, id]);
      res.json({ message: 'User role updated successfully' });
    } catch (error) {
      console.error('Error updating user role:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });

  router.post('/upload-avatar', authMiddleware, upload.single('avatar'), async (req, res) => {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }
  
    try {
      const userId = (req as any).user.id;
      const profilePictureUrl = `/uploads/${req.file.filename}`;
      
      await pool.query('UPDATE users SET profile_picture_url = $1 WHERE id = $2', [profilePictureUrl, userId]);
      
      res.json({ profilePictureUrl });
    } catch (error) {
      console.error('Avatar upload error:', error);
      res.status(500).json({ message: 'Server error during avatar upload' });
    }
  });
  
  // Update the existing /profile PUT route
  router.put('/profile', authMiddleware, async (req, res) => {
    try {
      const userId = (req as any).user.id;
      const { firstName, lastName, email, timezone } = req.body;
  
      const result = await pool.query(
        'UPDATE users SET first_name = $1, last_name = $2, email = $3, timezone = $4 WHERE id = $5 RETURNING id, username, email, first_name, last_name, timezone, profile_picture_url',
        [firstName, lastName, email, timezone, userId]
      );
  
      if (result.rows.length === 0) {
        return res.status(404).json({ message: 'User not found' });
      }
  
      res.json(result.rows[0]);
    } catch (error) {
      console.error('Profile update error:', error);
      res.status(500).json({ message: 'Server error during profile update' });
    }
  });

  router.post('/upload-avatar', authMiddleware, upload.single('avatar'), async (req, res) => {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }
  
    try {
      const userId = (req as any).user.id;
      const profilePictureUrl = `/uploads/${req.file.filename}`;
      
      await pool.query('UPDATE users SET profile_picture_url = $1 WHERE id = $2', [profilePictureUrl, userId]);
      
      res.json({ profilePictureUrl });
    } catch (error) {
      console.error('Avatar upload error:', error);
      res.status(500).json({ message: 'Server error during avatar upload' });
    }
  });

export default router;

================
File: src/server.ts
================
// services/auth/src/server.ts
import express from 'express';
import cors from 'cors';
import authRoutes from './routes/auth';
import path from 'path';
import { Pool } from 'pg';
import dotenv from 'dotenv';

const app = express();
const PORT = process.env.PORT || 3001;

dotenv.config({ path: path.resolve(__dirname, '../../.env') });

app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization'],
}));

app.use(express.json());

app.use('/auth', authRoutes);

app.listen(PORT, () => {
  console.log(`Auth service running on port ${PORT}`);
});

app.use('/uploads', express.static(path.join(__dirname, '..', 'uploads')))

const pool = new Pool({
  user: process.env.DB_USER || 'newcloud_user',
  host: process.env.DB_HOST || 'localhost',
  database: process.env.DB_NAME || 'newcloud',
  password: process.env.DB_PASSWORD,
  port: parseInt(process.env.DB_PORT || '5432'),
  options: '-c search_path=newcloud_schema,public'
});

// Add this for debugging
pool.on('error', (err) => {
  console.error('Unexpected error on idle client', err);
  process.exit(-1);
});

export default pool;

console.log('Database connection details:');
console.log('DB_USER:', process.env.DB_USER);
console.log('DB_HOST:', process.env.DB_HOST);
console.log('DB_NAME:', process.env.DB_NAME);
console.log('DB_PASSWORD:', process.env.DB_PASSWORD ? '[REDACTED]' : 'Not set');
console.log('DB_PORT:', process.env.DB_PORT);

================
File: test-db-connection.js
================
const path = require('path');
require('dotenv').config();
const migrate = require('node-pg-migrate').default;

const dbConfig = {
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '5432'),
  database: process.env.DB_NAME,
};

const databaseUrl = `postgres://${dbConfig.user}:${encodeURIComponent(dbConfig.password)}@${dbConfig.host}:${dbConfig.port}/${dbConfig.database}?search_path=newcloud_schema,public`;

async function runMigration() {
  try {
    await migrate({
      databaseUrl: databaseUrl,
      schema: 'newcloud_schema',
      migrationsTable: 'pgmigrations',
      dir: 'migrations',
      direction: 'up',
      count: Infinity,
    });
    console.log('Migration completed successfully');
  } catch (error) {
    console.error('Migration failed:', error);
  }
}

runMigration();

================
File: tsconfig.json
================
{
    "compilerOptions": {
      "target": "es6",
      "module": "commonjs",
      "outDir": "./dist",
      "rootDir": "./src",
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true,
      "resolveJsonModule": true,
      "typeRoots": ["./node_modules/@types", "./src/types"]
    },
    "include": ["src/**/*", "src/server.ts"],
    "exclude": ["node_modules"]
  }

================
File: services/auth/run-migration.js
================
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: parseInt(process.env.DB_PORT || '5432'),
});

async function verifyAndCreateSchema() {
  const client = await pool.connect();
  try {
    console.log('Successfully connected to the database');

    // Check search_path
    const searchPathResult = await client.query('SHOW search_path');
    console.log('Current search_path:', searchPathResult.rows[0].search_path);

    // List all schemas
    const allSchemasResult = await client.query(`
      SELECT schema_name 
      FROM information_schema.schemata 
      WHERE schema_name NOT LIKE 'pg_%' AND schema_name != 'information_schema'
    `);
    console.log('Available schemas:', allSchemasResult.rows.map(row => row.schema_name));

    // Check if the schema exists
    const schemaResult = await client.query(`
      SELECT schema_name 
      FROM information_schema.schemata 
      WHERE schema_name = 'newcloud_schema'
    `);
    
    if (schemaResult.rows.length > 0) {
      console.log('newcloud_schema exists');
    } else {
      console.log('newcloud_schema does not exist, attempting to create...');
      await client.query('CREATE SCHEMA IF NOT EXISTS newcloud_schema');
      console.log('newcloud_schema created');
    }

    // Set search_path to include newcloud_schema
    await client.query('SET search_path TO newcloud_schema, public');
    console.log('Set search_path to include newcloud_schema');

    // Check user permissions
    const permissionsResult = await client.query(`
      SELECT has_schema_privilege('${process.env.DB_USER}', 'newcloud_schema', 'CREATE')
    `);
    console.log('User has CREATE permission on newcloud_schema:', permissionsResult.rows[0].has_schema_privilege);

  } catch (err) {
    console.error('Error:', err);
  } finally {
    client.release();
    await pool.end();
  }
}

verifyAndCreateSchema();

================
File: services/auth/src/auth.ts
================
// services/auth/src/auth.ts

import jwt from 'jsonwebtoken';
import { Request, Response, NextFunction } from 'express';

const JWT_SECRET = process.env.JWT_SECRET || 'test@69lol';

interface User {
  id: string;
  username: string;
}

export function generateToken(user: { id: string; username: string }): string {
    return jwt.sign({ id: user.id, username: user.username }, JWT_SECRET, { expiresIn: '1d' });
  }
  
  export function authMiddleware(req: Request, res: Response, next: NextFunction) {
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      return res.status(401).json({ message: 'No token provided' });
    }
  
    const token = authHeader.split(' ')[1];
    if (!token) {
      return res.status(401).json({ message: 'No token provided' });
    }
  
    try {
      const decoded = jwt.verify(token, JWT_SECRET) as { id: string; username: string };
      (req as any).user = decoded;
      next();
    } catch (error) {
      return res.status(401).json({ message: 'Invalid token' });
    }
  }

================
File: services/auth/src/routes/auth.ts
================
// services/auth/src/routes/auth.ts

import express from 'express';
import bcrypt from 'bcrypt';
import { generateToken, authMiddleware } from '../auth';
import pool from '../server';
import multer from 'multer';
import path from 'path';
import fs from 'fs';

const router = express.Router();

const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, path.join(__dirname, '..', 'uploads'));
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({ storage: storage });

const uploadDir = path.join(__dirname, '..', 'uploads');
console.log('Upload directory:', uploadDir);

if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}


router.post('/upload-avatar', authMiddleware, upload.single('avatar'), async (req, res) => {
  if (!req.file) {
    return res.status(400).json({ message: 'No file uploaded' });
  }

  try {
    const userId = (req as any).user.id;
    const profilePictureUrl = `/uploads/${req.file.filename}`;
    
    await pool.query('UPDATE newcloud_schema.users SET profile_picture_url = $1 WHERE id = $2', [profilePictureUrl, userId]);
    
    console.log('File uploaded:', req.file);
    console.log('Profile picture URL:', profilePictureUrl);

    res.json({ profilePictureUrl });
  } catch (error) {
    console.error('Avatar upload error:', error);
    res.status(500).json({ message: 'Server error during avatar upload' });
  }
});

router.post('/register', async (req, res) => {
  const { username, email, password, firstName, lastName, timezone } = req.body;

  if (!username || !password || !firstName || !lastName) {
    return res.status(400).json({ message: 'Username, password, first name, and last name are required' });
  }

  try {
    console.log('Received registration request:', { username, email, firstName, lastName, timezone, passwordLength: password ? password.length : 0 });

    // Check if user already exists
    const userCheck = await pool.query('SELECT * FROM newcloud_schema.users WHERE username = $1', [username]);
    if (userCheck.rows.length > 0) {
      return res.status(400).json({ message: 'Username already exists' });
    }

    // Check if email exists if provided
    if (email) {
      const emailCheck = await pool.query('SELECT * FROM newcloud_schema.users WHERE email = $1', [email]);
      if (emailCheck.rows.length > 0) {
        return res.status(400).json({ message: 'Email already in use' });
      }
    }

    // Hash password
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(String(password), salt);

    // Get the 'user' role id
    const roleResult = await pool.query('SELECT id FROM newcloud_schema.roles WHERE name = $1', ['user']);
    if (roleResult.rows.length === 0) {
      return res.status(500).json({ message: 'Default role not found' });
    }
    const roleId = roleResult.rows[0].id;

    // Insert new user with the 'user' role
const newUser = await pool.query(
  'INSERT INTO newcloud_schema.users (username, email, password, first_name, last_name, timezone, role_id) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, username',
  [username, email || null, hashedPassword, firstName, lastName, timezone || 'America/Boise', roleId]
);

    const token = generateToken({ id: newUser.rows[0].id, username: newUser.rows[0].username });
    res.status(201).json({ token });
  } catch (error) {
    console.error('Registration error:', error);
    if (error instanceof Error) {
      res.status(500).json({ message: 'Server error during registration', error: error.message });
    } else {
      res.status(500).json({ message: 'Server error during registration' });
    }
  }
});
  
  router.post('/login', async (req, res) => {
    const { username, password } = req.body;
  
    try {
      const user = await pool.query('SELECT * FROM newcloud_schema.users WHERE username = $1', [username]);
  
      if (user.rows.length === 0) {
        return res.status(400).json({ message: 'Invalid credentials' });
      }
  
      const validPassword = await bcrypt.compare(password, user.rows[0].password);
      if (!validPassword) {
        return res.status(400).json({ message: 'Invalid credentials' });
      }
  
      const token = generateToken({ id: user.rows[0].id, username: user.rows[0].username });
      res.json({ token });
    } catch (error) {
        console.error('Login error:', error);
        if (error instanceof Error) {
          res.status(500).json({ message: 'Server error during login', error: error.message });
        } else {
          res.status(500).json({ message: 'Server error during login' });
        }
      }
  });

router.get('/profile', authMiddleware, async (req, res) => {
    try {
      const userId = (req as any).user.id;
      const result = await pool.query(
        'SELECT u.id, u.username, u.email, r.name as role FROM users u JOIN roles r ON u.role_id = r.id WHERE u.id = $1',
        [userId]
      );
      
      if (result.rows.length === 0) {
        return res.status(404).json({ message: 'User not found' });
      }
  
      console.log('Profile data:', result.rows[0]); // Add this line
  
      res.json(result.rows[0]);
    } catch (error) {
      console.error('Profile fetch error:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });

router.put('/profile', authMiddleware, async (req, res) => {
  try {
    const userId = (req as any).user.id;
    const { username, email } = req.body;

    // Check if username already exists
    if (username) {
      const usernameCheck = await pool.query('SELECT id FROM users WHERE username = $1 AND id != $2', [username, userId]);
      if (usernameCheck.rows.length > 0) {
        return res.status(400).json({ message: 'Username already taken' });
      }
    }

    // Update user profile
    const result = await pool.query(
      'UPDATE users SET username = COALESCE($1, username), email = COALESCE($2, email) WHERE id = $3 RETURNING id, username, email',
      [username, email, userId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ message: 'User not found' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    console.error('Profile update error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

router.put('/change-password', authMiddleware, async (req, res) => {
    try {
      const userId = (req as any).user.id;
      const { currentPassword, newPassword } = req.body;
  
      // Fetch the user from the database
      const userResult = await pool.query('SELECT * FROM users WHERE id = $1', [userId]);
      if (userResult.rows.length === 0) {
        return res.status(404).json({ message: 'User not found' });
      }
  
      const user = userResult.rows[0];
  
      // Verify current password
      const isValidPassword = await bcrypt.compare(currentPassword, user.password);
      if (!isValidPassword) {
        return res.status(400).json({ message: 'Current password is incorrect' });
      }
  
      // Hash the new password
      const salt = await bcrypt.genSalt(10);
      const hashedNewPassword = await bcrypt.hash(newPassword, salt);
  
      // Update the password in the database
      await pool.query('UPDATE users SET password = $1 WHERE id = $2', [hashedNewPassword, userId]);
  
      res.json({ message: 'Password updated successfully' });
    } catch (error) {
      console.error('Password change error:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });

  router.post('/upload-avatar', authMiddleware, upload.single('avatar'), async (req, res) => {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }
  
    try {
      const userId = (req as any).user.id;
      const profilePictureUrl = `/uploads/${req.file.filename}`; // This should be a URL, not a file path
      
      await pool.query('UPDATE users SET profile_picture_url = $1 WHERE id = $2', [profilePictureUrl, userId]);
      
      res.json({ profilePictureUrl });
    } catch (error) {
      console.error('Avatar upload error:', error);
      res.status(500).json({ message: 'Server error during avatar upload' });
    }
  });

  const isSiteAdmin = async (req: any, res: any, next: any) => {
    const userId = req.user.id;
    const result = await pool.query(
      'SELECT r.name FROM users u JOIN roles r ON u.role_id = r.id WHERE u.id = $1',
      [userId]
    );
    if (result.rows[0]?.name === 'site_admin') {
      next();
    } else {
      res.status(403).json({ message: 'Access denied' });
    }
  };
  
  // Middleware to check if user is an application admin or site admin
  const isAdmin = async (req: any, res: any, next: any) => {
    const userId = req.user.id;
    const result = await pool.query(
      'SELECT r.name FROM users u JOIN roles r ON u.role_id = r.id WHERE u.id = $1',
      [userId]
    );
    if (['site_admin', 'application_admin'].includes(result.rows[0]?.name)) {
      next();
    } else {
      res.status(403).json({ message: 'Access denied' });
    }
  };
  
  // Route to get all users (admin only)
  router.get('/users', authMiddleware, isAdmin, async (req, res) => {
    try {
      const result = await pool.query('SELECT u.id, u.username, u.email, r.name as role FROM users u JOIN roles r ON u.role_id = r.id');
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching users:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });
  
  // Route to update user role (site admin only)
  router.put('/users/:id/role', authMiddleware, isSiteAdmin, async (req, res) => {
    const { id } = req.params;
    const { role } = req.body;
  
    try {
      const roleResult = await pool.query('SELECT id FROM roles WHERE name = $1', [role]);
      if (roleResult.rows.length === 0) {
        return res.status(400).json({ message: 'Invalid role' });
      }
  
      const roleId = roleResult.rows[0].id;
      await pool.query('UPDATE users SET role_id = $1 WHERE id = $2', [roleId, id]);
      res.json({ message: 'User role updated successfully' });
    } catch (error) {
      console.error('Error updating user role:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });

  router.put('/users/:id/role', authMiddleware, isSiteAdmin, async (req, res) => {
    const { id } = req.params;
    const { role } = req.body;
  
    try {
      // Check if the role is valid
      const validRoles = ['user', 'application_admin', 'site_admin'];
      if (!validRoles.includes(role)) {
        return res.status(400).json({ message: 'Invalid role' });
      }
  
      const roleResult = await pool.query('SELECT id FROM roles WHERE name = $1', [role]);
      if (roleResult.rows.length === 0) {
        return res.status(400).json({ message: 'Invalid role' });
      }
  
      const roleId = roleResult.rows[0].id;
      await pool.query('UPDATE users SET role_id = $1 WHERE id = $2', [roleId, id]);
      res.json({ message: 'User role updated successfully' });
    } catch (error) {
      console.error('Error updating user role:', error);
      res.status(500).json({ message: 'Server error' });
    }
  });

  router.post('/upload-avatar', authMiddleware, upload.single('avatar'), async (req, res) => {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }
  
    try {
      const userId = (req as any).user.id;
      const profilePictureUrl = `/uploads/${req.file.filename}`;
      
      await pool.query('UPDATE users SET profile_picture_url = $1 WHERE id = $2', [profilePictureUrl, userId]);
      
      res.json({ profilePictureUrl });
    } catch (error) {
      console.error('Avatar upload error:', error);
      res.status(500).json({ message: 'Server error during avatar upload' });
    }
  });
  
  // Update the existing /profile PUT route
  router.put('/profile', authMiddleware, async (req, res) => {
    try {
      const userId = (req as any).user.id;
      const { firstName, lastName, email, timezone } = req.body;
  
      const result = await pool.query(
        'UPDATE users SET first_name = $1, last_name = $2, email = $3, timezone = $4 WHERE id = $5 RETURNING id, username, email, first_name, last_name, timezone, profile_picture_url',
        [firstName, lastName, email, timezone, userId]
      );
  
      if (result.rows.length === 0) {
        return res.status(404).json({ message: 'User not found' });
      }
  
      res.json(result.rows[0]);
    } catch (error) {
      console.error('Profile update error:', error);
      res.status(500).json({ message: 'Server error during profile update' });
    }
  });

  router.post('/upload-avatar', authMiddleware, upload.single('avatar'), async (req, res) => {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }
  
    try {
      const userId = (req as any).user.id;
      const profilePictureUrl = `/uploads/${req.file.filename}`;
      
      await pool.query('UPDATE users SET profile_picture_url = $1 WHERE id = $2', [profilePictureUrl, userId]);
      
      res.json({ profilePictureUrl });
    } catch (error) {
      console.error('Avatar upload error:', error);
      res.status(500).json({ message: 'Server error during avatar upload' });
    }
  });

export default router;

================
File: services/auth/src/server.ts
================
import express from 'express';
import cors from 'cors';
import authRoutes from './routes/auth';
import path from 'path';
import { Pool } from 'pg';
import dotenv from 'dotenv';

dotenv.config({ path: path.resolve(__dirname, '../../../.env') });

const app = express();
const PORT = process.env.PORT || 3001;



app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization'],
}));

app.use(express.json());

app.use('/auth', authRoutes);

const server = app.listen(PORT, () => {
  console.log(`Auth service running on port ${PORT}`);
});

const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD ? String(process.env.DB_PASSWORD) : undefined,
  port: parseInt(process.env.DB_PORT || '5432'),
  options: '-c search_path=newcloud_schema,public'
});

const uploadDir = path.join(__dirname, '..', 'uploads');
app.use('/uploads', express.static(uploadDir));

// Use auth routes
app.use('/auth', authRoutes);

pool.on('error', (err) => {
  console.error('Unexpected error on idle client', err);
});

// Test database connection
pool.query('SELECT NOW()', (err, res) => {
  if (err) {
    console.error('Error connecting to the database:', err);
  } else {
    console.log('Successfully connected to the database');
  }
});

console.log('Database connection details:');
console.log('DB_USER:', process.env.DB_USER);
console.log('DB_HOST:', process.env.DB_HOST);
console.log('DB_NAME:', process.env.DB_NAME);
console.log('DB_PASSWORD is set:', !!process.env.DB_PASSWORD);
console.log('DB_PORT:', process.env.DB_PORT);

export default pool;

================
File: services/auth/test-db-connection.js
================
const path = require('path');
require('dotenv').config();
const migrate = require('node-pg-migrate').default;

const dbConfig = {
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '5432'),
  database: process.env.DB_NAME,
};

const databaseUrl = `postgres://${dbConfig.user}:${encodeURIComponent(dbConfig.password)}@${dbConfig.host}:${dbConfig.port}/${dbConfig.database}?search_path=newcloud_schema,public`;

async function runMigration() {
  try {
    await migrate({
      databaseUrl: databaseUrl,
      schema: 'newcloud_schema',
      migrationsTable: 'pgmigrations',
      dir: 'migrations',
      direction: 'up',
      count: Infinity,
    });
    console.log('Migration completed successfully');
  } catch (error) {
    console.error('Migration failed:', error);
  }
}

runMigration();

================
File: services/auth/tsconfig.json
================
{
    "compilerOptions": {
      "target": "es6",
      "module": "commonjs",
      "outDir": "./dist",
      "rootDir": "./src",
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true,
      "resolveJsonModule": true,
      "typeRoots": ["./node_modules/@types", "./src/types"],
      "moduleResolution": "node"
    },
    "include": ["src/**/*", "src/server.ts"],
    "exclude": ["node_modules"]
  }
